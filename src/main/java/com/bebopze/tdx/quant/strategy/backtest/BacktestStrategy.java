package com.bebopze.tdx.quant.strategy.backtest;

import com.alibaba.fastjson2.JSON;
import com.bebopze.tdx.quant.common.cache.BacktestCache;
import com.bebopze.tdx.quant.common.config.BizException;
import com.bebopze.tdx.quant.common.config.anno.TotalTime;
import com.bebopze.tdx.quant.common.constant.BtTradeTypeEnum;
import com.bebopze.tdx.quant.common.constant.SellStrategyEnum;
import com.bebopze.tdx.quant.common.constant.TopBlockStrategyEnum;
import com.bebopze.tdx.quant.common.util.*;
import com.bebopze.tdx.quant.dal.entity.*;
import com.bebopze.tdx.quant.dal.service.*;
import com.bebopze.tdx.quant.parser.check.TdxFunCheck;
import com.bebopze.tdx.quant.service.InitDataService;
import com.bebopze.tdx.quant.service.MarketService;
import com.bebopze.tdx.quant.service.impl.InitDataServiceImpl;
import com.bebopze.tdx.quant.strategy.buy.BacktestBuyStrategyC;
import com.bebopze.tdx.quant.strategy.buy.BuyStrategyFactory;
import com.bebopze.tdx.quant.strategy.sell.SellStrategyFactory;
import com.google.common.collect.Lists;
import com.google.common.collect.Maps;
import com.google.common.collect.Sets;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.Synchronized;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.collections4.CollectionUtils;
import org.springframework.beans.BeanUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;
import org.springframework.util.Assert;

import java.io.Serializable;
import java.math.BigDecimal;
import java.math.RoundingMode;
import java.time.LocalDate;
import java.util.*;
import java.util.stream.Collectors;


/**
 * B/SÁ≠ñÁï• - ÂõûÊµã                    //     B/SÁ≠ñÁï• Êú¨Ë¥®       =>       Ê®°ÂºèÊàêÂäü  üü∞ Â§ßÁõò(70) ‚ûï ‰∏ªÁ∫ø(25) ‚ûï ‰π∞ÁÇπ(5)
 *
 * @author: bebopze
 * @date: 2025/5/27
 */
@Data
@Slf4j
@Component
public class BacktestStrategy {


    // ÂÖ±‰∫´Êï∞ÊçÆ
    private static volatile BacktestCache data = InitDataServiceImpl.data;


    // -----------------------------------------------------------------------------------------------------------------


    // ÁªüËÆ°Êï∞ÊçÆ
    private static final ThreadLocal<Stat> x = ThreadLocal.withInitial(Stat::new);


    // -----------------------------------------------------------------------------------------------------------------


    /**
     * bt_trade_record   -   Cache
     */
    private static final ThreadLocal<Set<Long>> tradeRecord___idSet__cache = ThreadLocal.withInitial(HashSet::new);
    private static final ThreadLocal<List<BtTradeRecordDO>> tradeRecordList__cache = ThreadLocal.withInitial(ArrayList::new);


    // -----------------------------------------------------------------------------------------------------------------


    @Autowired
    private IBtTaskService btTaskService;

    @Autowired
    private IBtTradeRecordService btTradeRecordService;

    @Autowired
    private IBtPositionRecordService btPositionRecordService;

    @Autowired
    private IBtDailyReturnService btDailyReturnService;


    @Autowired
    private InitDataService initDataService;


    @Autowired
    private BuyStrategyFactory buyStrategyFactory;

    @Autowired
    private BacktestBuyStrategyC backtestBuyStrategyC;

    @Autowired
    private SellStrategyFactory sellStrategyFactory;


    @Autowired
    private MarketService marketService;


    @Autowired
    private TradePairStat tradePairStat;


    // -----------------------------------------------------------------------------------------------------------------


    @TotalTime
    public Long backtest(Integer batchNo,
                         TopBlockStrategyEnum topBlockStrategyEnum, List<String> buyConList, List<String> sellConList,
                         LocalDate startDate, LocalDate endDate) {

        try {
            return execBacktest(batchNo, topBlockStrategyEnum, buyConList, sellConList, startDate, endDate);
        } finally {
            clearThreadLocal();
        }
    }


    private Long execBacktest(Integer batchNo,
                              TopBlockStrategyEnum topBlockStrategyEnum,
                              List<String> buyConList,
                              List<String> sellConList,
                              LocalDate startDate,
                              LocalDate endDate) {

        log.info("execBacktest start     >>>     batchNo : {} , topBlockStrategyEnum : {} , buyConList : {} , sellConList : {} , startDate : {} , endDate : {}",
                 batchNo, topBlockStrategyEnum, buyConList, sellConList, startDate, endDate);


        endDate = DateTimeUtil.min(endDate, LocalDate.now());


        // -------------------------------------------------------------------------------------------------------------
        //                              ÂõûÊµã-task   pre   ==>   ÊùøÂùó„ÄÅ‰∏™ËÇ°   Ë°åÊÉÖÊï∞ÊçÆ ÂàùÂßãÂåñ
        // -------------------------------------------------------------------------------------------------------------


        // Êï∞ÊçÆÂàùÂßãÂåñ   ->   Âä†ËΩΩ ÂÖ®ÈáèË°åÊÉÖÊï∞ÊçÆ
        log.info("--------------------------- " + Thread.currentThread().getName() + "Á∫øÁ®ã Á≠âÂæÖüîê     >>>     üò¥ing");
        long start = System.currentTimeMillis();
        initData(startDate, endDate);
        log.info("--------------------------- " + Thread.currentThread().getName() + "Á∫øÁ®ã ÈáäÊîæüîê     >>>     ‚úÖ ËÄóÊó∂Ôºö" + DateTimeUtil.formatNow2Hms(start));


        // -------------------------------------------------------------------------------------------------------------
        //                                            ÂõûÊµã-task   ÂàõÂª∫
        // -------------------------------------------------------------------------------------------------------------


        BtTaskDO taskDO = createBacktestTask(batchNo, topBlockStrategyEnum, buyConList, sellConList, startDate, endDate);


        // -------------------------------------------------------------------------------------------------------------
        //                                            ÂõûÊµã-task   ÊåâÊó• Âæ™ÁéØÊâßË°å
        // -------------------------------------------------------------------------------------------------------------


        LocalDate tradeDate = taskDO.getStartDate().minusDays(1);
        endDate = DateTimeUtil.min(taskDO.getEndDate(), data.endDate());


        // ÊÄªËµÑÈáë
        x.get().prevCapital = taskDO.getInitialCapital().doubleValue();
        // ÂèØÁî®ÈáëÈ¢ù
        x.get().prevAvlCapital = taskDO.getInitialCapital().doubleValue();


        while (tradeDate.isBefore(endDate)) {

            tradeDate = tradeDateIncr(tradeDate);
            // Â§á‰ªΩ
            Backup backup = backupThreadLocal();


            try {
                // ÊØèÊó• - ÂõûÊµãÔºàB/SÔºâ
                execBacktestDaily(topBlockStrategyEnum, buyConList, sellConList, tradeDate, taskDO);
            } catch (Exception e) {
                log.error("execBacktestDaily     >>>     taskId : {} , tradeDate : {} , exMsg : {}", taskDO.getId(), tradeDate, e.getMessage(), e);


                // retry
                retryExecBacktestDaily(topBlockStrategyEnum, buyConList, sellConList, tradeDate, taskDO, backup, 5);
            }
        }


        // -------------------------------------------------------------------------------------------------------------
        //                                            ÊÄªÊî∂Áõä
        // -------------------------------------------------------------------------------------------------------------


        sumTotalReturn(taskDO);


        log.info("execBacktest end     >>>     taskId : {} , startDate : {} , endDate : {}", taskDO.getId(), startDate, endDate);


        return taskDO.getId();
    }

    private void retryExecBacktestDaily(TopBlockStrategyEnum topBlockStrategyEnum,
                                        List<String> buyConList,
                                        List<String> sellConList,
                                        LocalDate tradeDate,
                                        BtTaskDO taskDO,
                                        Backup backup,
                                        int retry) {


        log.info("retryExecBacktestDaily - start     >>>     retry : {} , taskId : {} , tradeDate : {} , topBlockStrategyEnum : {} , buyConList : {} , sellConList : {}",
                 retry - 1, taskDO.getId(), tradeDate, topBlockStrategyEnum, buyConList, sellConList);


        if (--retry < 0) {
            return;
        }


        // ÊÅ¢Â§ç
        restoreThreadLocal(backup);


        try {

            // ÊØèÊó• - ÂõûÊµãÔºàB/SÔºâ
            execBacktestDaily(topBlockStrategyEnum, buyConList, sellConList, tradeDate, taskDO);

            log.info("retryExecBacktestDaily - suc     >>>     retry : {} , taskId : {} , tradeDate : {} , topBlockStrategyEnum : {} , buyConList : {} , sellConList : {}",
                     retry, taskDO.getId(), tradeDate, topBlockStrategyEnum, buyConList, sellConList);


        } catch (Exception e) {

            log.error("retryExecBacktestDaily - fail     >>>     retry : {} , taskId : {} , tradeDate : {} , topBlockStrategyEnum : {} , buyConList : {} , sellConList : {}   ,   exMsg : {}",
                      retry, taskDO.getId(), tradeDate, topBlockStrategyEnum, buyConList, sellConList, e.getMessage(), e);


            retryExecBacktestDaily(topBlockStrategyEnum, buyConList, sellConList, tradeDate, taskDO, backup, retry);


            // ÈáçËØïÂ§±Ë¥•   ->   ‰∏≠Êñ≠ ÂºÇÂ∏∏task
            throw e;
        }
    }


    private BtTaskDO createBacktestTask(Integer batchNo,
                                        TopBlockStrategyEnum topBlockStrategyEnum,
                                        List<String> buyConList,
                                        List<String> sellConList,
                                        LocalDate startDate,
                                        LocalDate endDate) {

        BtTaskDO taskDO = new BtTaskDO();

        // ‰ªªÂä°ÊâπÊ¨°Âè∑
        taskDO.setBatchNo(batchNo);
        // ‰ªªÂä°Áä∂ÊÄÅ
        taskDO.setStatus(1);

        // B/SÁ≠ñÁï•
        taskDO.setTopBlockStrategy(topBlockStrategyEnum.getDesc());
        taskDO.setBuyStrategy(String.join(",", buyConList));
        taskDO.setSellStrategy(String.join(",", sellConList));


        // ÂõûÊµã - Êó∂Èó¥ÊÆµ
        taskDO.setStartDate(startDate);
        taskDO.setEndDate(endDate);

        // ÂàùÂßãÊú¨Èáë
        taskDO.setInitialCapital(BigDecimal.valueOf(100_0000));
        // ÂàùÂßãÂáÄÂÄº
        taskDO.setInitialNav(BigDecimal.valueOf(1.0000));


        btTaskService.save(taskDO);


        return taskDO;
    }


    private void execBacktestDaily(TopBlockStrategyEnum topBlockStrategyEnum,
                                   List<String> buyConList,
                                   List<String> sellConList,
                                   LocalDate tradeDate,
                                   BtTaskDO taskDO) {


        Long taskId = taskDO.getId();


        x.get().taskId = taskDO.getId();
        x.get().tradeDate = tradeDate;


        x.get().avlCapital = x.get().prevAvlCapital;
        // ÊÄªËµÑÈáë     =>     ‰ªäÊó• ËÆ°ÁÆóÂâç -> ÂÖàÂèñ Êò®Êó•ÊÄªËµÑÈáë
        x.get().capital = x.get().prevCapital;


        // -------------------------------------------------------------------------------------------------------------
        //                                            ÊØèÊó•ÊåÅ‰ªìÔºàSÂâçÔºâ
        // -------------------------------------------------------------------------------------------------------------


        // -------------------------------------------------- ÂçñÂá∫Á≠ñÁï•Ôºà ÂÖàS[Ê∑òÊ±∞]  =>  Á©∫‰ΩôËµÑÈáë  ->  B[Êñ∞‰∏äÊ¶ú] Ôºâ


        // -------------------------------------------------------------------------------------------------------------
        //                                                1„ÄÅÂ§ßÁõò -> ‰ªì‰Ωç
        // -------------------------------------------------------------------------------------------------------------


        // Â§ßÁõòÈáèÂåñ   ->   ÊÄª‰ªì‰Ωç ÈôêÂà∂
        market__position_limit(tradeDate);


        // SÂâç -> Ë¥¶Êà∑Êï∞ÊçÆ
        sell_before___statData___step1__init();


        // -------------------------------------------------------------------------------------------------------------
        //                                            SÁ≠ñÁï•
        // -------------------------------------------------------------------------------------------------------------


        Map<String, SellStrategyEnum> sell_infoMap = Maps.newHashMap();


        // ÂçñÂá∫Á≠ñÁï•
        Set<String> sell__stockCodeSet = sellStrategyFactory.get("A").rule(topBlockStrategyEnum, data, tradeDate, x.get().positionStockCodeList, sell_infoMap);

        log.info("SÁ≠ñÁï•     >>>     [{}] [{}] , topBlockStrategyEnum : {} , size : {} , sell__stockCodeSet : {} , sell_infoMap : {}",
                 taskId, tradeDate, topBlockStrategyEnum, sell__stockCodeSet.size(), JSON.toJSONString(sell__stockCodeSet), JSON.toJSONString(sell_infoMap));


        // ÊåÅ‰ªì‰∏™ËÇ°   ->   ÂåπÈÖç Ê∑òÊ±∞


        // 2.1„ÄÅÂΩìÊó• SÁ≠ñÁï•ÔºàÁ†¥‰Ωç -> SÊ∑òÊ±∞Ôºâ -> stockCodeListÔºàÂØπÊò®Êó• ÊåÅËÇ° -> SÊ∑òÊ±∞Ôºâ

        // 2.2 ÊØèÊó• Ê∑òÊ±∞Á≠ñÁï•ÔºàSÁ≠ñÁï• - 2Ôºâ[ÊéíÂêç]Ëµ∞Âº± -> Êú´‰ΩçÊ∑òÊ±∞ ->  stockCodeListÔºàÂØπÊò®Êó• ÊåÅËÇ° -> Êú´‰ΩçÊ∑òÊ±∞[ËÆæÁΩÆÊú´Â∞æÊ∑òÊ±∞ - ÂàÜÊï∞Á∫ø/ÊéíÂêçÁ∫ø ]Ôºâ


        // -------------------------------------------------------------------------------------------------------------
        //                                            SÁ≠ñÁï• -> ‰∫§Êòì record
        // -------------------------------------------------------------------------------------------------------------


        // SÁ≠ñÁï•   ->   SELL TradeRecord
        createAndSave__SELL_TradeRecord(taskId, tradeDate, sell__stockCodeSet, x.get().stockCode_positionDO_Map, sell_infoMap);


        // SÂêé  ->  Ë¥¶Êà∑ÁªüËÆ°Êï∞ÊçÆ
        refresh_statData();


        // ----------------------- SÂêé ‰ªì‰ΩçÊ†°È™å   =>   ÊòØÂê¶ÈúÄË¶Å ÁªßÁª≠Âáè‰ªì

        // SÂêé ÊÄªÊåÅ‰ªìÂ∏ÇÂÄº  >  ‰ªì‰ΩçÊÄªÈáëÈ¢ù ‰∏äÈôê     =>     Á≠âÊØîÂáè‰ªì
        if (x.get().marketValue > x.get().positionLimitAmount) {

            // ÂÆûÈôÖ ÂèØÁî®ËµÑÈáë < 0
            x.get().actAvlCapital = 0;

            // Á≠âÊØîÂáè‰ªì
            ÊåÅ‰ªì_Â§ß‰∫é_ÊåÅ‰ªì‰∏äÈôê___Á≠âÊØîÂáè‰ªì(taskId, tradeDate);


            // Âáè‰ªìÂêéÔºà2Ê¨° SÔºâ ->  Ë¥¶Êà∑ÁªüËÆ°Êï∞ÊçÆ
            refresh_statData();
        }


        // -------------------------------------------------------------------------------------------------------------
        //                                            BÁ≠ñÁï•
        // -------------------------------------------------------------------------------------------------------------


        Map<String, String> buy_infoMap = Maps.newConcurrentMap();
        // ÂΩìÂâç‰ªì‰Ωç
        double posRate = x.get().getMarketValue() / x.get().getCapital();


        // ‰π∞ÂÖ•Á≠ñÁï•
        // List<String> buy__stockCodeList = buyStrategyFactory.get("A").rule(data, tradeDate, buy_infoMap, posRate);
        List<String> buy__stockCodeList = backtestBuyStrategyC.rule2(topBlockStrategyEnum, buyConList, data, tradeDate, buy_infoMap, posRate);

        log.info("BÁ≠ñÁï•     >>>     [{}] [{}] , topBlockStrategyEnum : {} , size : {} , buy__stockCodeList : {} , buy_infoMap : {}",
                 taskId, tradeDate, topBlockStrategyEnum, buy__stockCodeList.size(), JSON.toJSONString(buy__stockCodeList), JSON.toJSONString(buy_infoMap));


        // -------------------------------------------------------------------------------------------------------------


        // TODO     Âêå‰∏ÄÊó•  ÂêåÊó∂Êª°Ë∂≥       SÁ≠ñÁï•ÔºàÈ´ò‰ΩçÁàÜÈáè‰∏äÂΩ±Â§ßÈò¥Ôºâ   +   BÁ≠ñÁï•ÔºàÊúàÂ§ö,60Êó•Êñ∞È´ò,SSFÂ§ö,RPS‰∏âÁ∫øÁ∫¢,Â§ßÂùáÁ∫øÂ§öÂ§¥Ôºâ

        // TODO       ==>       SÂçä‰ªì   /   SÔºàÊ∏Ö‰ªìÔºâ -> ‰∏çB


        // BÁ≠ñÁï• - SÁ≠ñÁï•   Áõ∏‰∫íÂÜ≤Á™Åbug       =>       ‰ª• SÁ≠ñÁï• ‰∏∫ÂáÜ       ->       Âá∫Áé∞ S‰ø°Âè∑ ‰∏™ËÇ°‰∏çËÉΩ‰π∞ÂÖ•ÔºàbuyList -> ÂâîÈô§Ôºâ
        buy_sell__signalConflict(topBlockStrategyEnum, data, tradeDate, buy__stockCodeList);


        // -------------------------------------------------------------------------------------------------------------
        //                                            BÁ≠ñÁï• -> ‰∫§Êòì record
        // -------------------------------------------------------------------------------------------------------------


        log.debug("BÁ≠ñÁï• -> ‰∫§Êòì record - start     >>>     [{}] [{}] , prevAvlCapital : {} , sellCapital : {} , avlCapital : {} , prevCapital : {}",
                  taskId, tradeDate, x.get().prevAvlCapital, x.get().sellCapital, x.get().avlCapital, x.get().prevCapital);


        // BÁ≠ñÁï•   ->   BUY TradeRecord
        createAndSave__BUY_TradeRecord(taskId, tradeDate, buy__stockCodeList, buy_infoMap);


        // BÂêé  ->  Ë¥¶Êà∑ÁªüËÆ°Êï∞ÊçÆ
        refresh_statData();


        // -------------------------------------------------------------------------------------------------------------
        //                                            ÊØèÊó•ÊåÅ‰ªì/Ê∏Ö‰ªì -> record
        // -------------------------------------------------------------------------------------------------------------


        // save -> DB
        // btPositionRecordService.retryBatchSave(x.get().positionRecordDOList);
        // btPositionRecordService.retryBatchSave(x.get().clearPositionRecordDOList);

        List<BtPositionRecordDO> holdAndClearPosList = Lists.newArrayList(x.get().positionRecordDOList);
        holdAndClearPosList.addAll(x.get().clearPositionRecordDOList);
        btPositionRecordService.retryBatchSave(holdAndClearPosList);


        // -------------------------------------------------------------------------------------------------------------
        //                                            ÊØèÊó•Êî∂Áõä
        // -------------------------------------------------------------------------------------------------------------


        calcDailyReturn(taskId, taskDO.getInitialCapital(), x.get().prevCapital, x.get().avlCapital, x.get().buyCapital, x.get().sellCapital, tradeDate, x.get().positionRecordDOList);


        // -------------------------------------------------------------------------------------------------------------


        // END   ->   prev ËµãÂÄº
        refresh_statData__prev();
    }


    // ------------------------------------------------------- S -------------------------------------------------------


    /**
     * SÁ≠ñÁï•   ->   SELL TradeRecord
     *
     * @param taskId
     * @param tradeDate
     * @param sell__stockCodeSet
     * @param sell_before__stockCode_positionDO_Map
     * @param sell_infoMap
     * @return
     */
    private void createAndSave__SELL_TradeRecord(Long taskId,
                                                 LocalDate tradeDate,
                                                 Set<String> sell__stockCodeSet,
                                                 Map<String, BtPositionRecordDO> sell_before__stockCode_positionDO_Map,
                                                 Map<String, SellStrategyEnum> sell_infoMap) {


        List<BtTradeRecordDO> sell__tradeRecordDO__List = Lists.newArrayList();


        for (String stockCode : sell__stockCodeSet) {

            BtTradeRecordDO sell_tradeRecordDO = new BtTradeRecordDO();
            sell_tradeRecordDO.setTaskId(taskId);
            sell_tradeRecordDO.setTradeType(BtTradeTypeEnum.SELL.getTradeType());
            sell_tradeRecordDO.setStockId(data.stock__codeIdMap.get(stockCode));
            sell_tradeRecordDO.setStockCode(stockCode);
            sell_tradeRecordDO.setStockName(data.stock__codeNameMap.get(stockCode));
            sell_tradeRecordDO.setTradeDate(tradeDate);


            // ‰∫§Êòì‰ø°Âè∑ -> typeÂàÜÁ±ªÔºà  ->  ÂàÜÁ±ªÁªüËÆ°  „ÄêSELLÊåáÊ†á„Äë  ËÉúÁéáÔºâ
            // sell_tradeRecordDO.setTradeSignal(sell_infoMap.get(stockCode));
            SellStrategyEnum sellStrategyEnum = sell_infoMap.get(stockCode);
            sell_tradeRecordDO.setTradeSignalType(sellStrategyEnum.getType());
            sell_tradeRecordDO.setTradeSignalDesc(sellStrategyEnum.getDesc());


            sell_tradeRecordDO.setPrice(NumUtil.double2Decimal(getClosePrice(stockCode, tradeDate)));
            sell_tradeRecordDO.setQuantity(sell_before__stockCode_positionDO_Map.get(stockCode).getQuantity());

            // Êàê‰∫§È¢ù = ‰ª∑Ê†º x Êï∞Èáè
            double amount = sell_tradeRecordDO.getPrice().doubleValue() * sell_tradeRecordDO.getQuantity();
            sell_tradeRecordDO.setAmount(of(amount));

            // ‰ªì‰ΩçÂç†ÊØî = ÊåÅ‰ªìÂ∏ÇÂÄº / ÊÄªËµÑÈáë
            double positionPct = amount / x.get().capital * 100;
            sell_tradeRecordDO.setPositionPct(of(positionPct));

            sell_tradeRecordDO.setFee(BigDecimal.ZERO);


            sell__tradeRecordDO__List.add(sell_tradeRecordDO);
        }


        // save
        btTradeRecordService.retryBatchSave(sell__tradeRecordDO__List);
    }


    // ------------------------------------------------------- S -------------------------------------------------------


    /**
     * ÊåÅ‰ªì > ÊåÅ‰ªì‰∏äÈôê     =>     Á≠âÊØîÂáè‰ªì
     *
     * @param taskId
     * @param tradeDate
     */
    private void ÊåÅ‰ªì_Â§ß‰∫é_ÊåÅ‰ªì‰∏äÈôê___Á≠âÊØîÂáè‰ªì(Long taskId, LocalDate tradeDate) {


        // ----------------------------------------------------------


        // Â∑≤Ê∏Ö‰ªì
        if (x.get().positionRecordDOList.isEmpty()) {
            return;
        }


        // ---------------------------------------------------------- Á≠âÊØîÂáè‰ªì


        // Âáè‰ªìÊÄªÈáëÈ¢ù  =  SÂêé_ÊåÅ‰ªìÊÄªÂ∏ÇÂÄº - ‰ªì‰ΩçÊÄªÈáëÈ¢ù_‰∏äÈôê
        double total_reduction_amount = x.get().marketValue - x.get().positionLimitAmount;


        // Âáè‰ªìÊÄªÈáëÈ¢ù Â∏ÇÂÄºÂç†ÊØî < 5%       Áõ¥Êé•Áï•Ëøá
        if (total_reduction_amount / x.get().marketValue < 0.05) {
            // ÈáëÈ¢ùÂ§™Â∞è  ->  Áï•Ëøá
            log.debug("[{}] [{}]     >>>     ÊåÅ‰ªì_Â§ß‰∫é_ÊåÅ‰ªìÈôêÂà∂___Á≠âÊØîÂáè‰ªì  -  Âáè‰ªìÊÄªÈáëÈ¢ù[{}] Â∏ÇÂÄºÂç†ÊØî[{}%]Â§™Â∞è -> Áï•Ëøá     >>>     marketValue : {} , positionLimitAmount : {}",
                      taskId, tradeDate,
                      total_reduction_amount, of(total_reduction_amount / x.get().marketValue * 100),
                      x.get().marketValue, x.get().positionLimitAmount);
            return;
        }


        // ÊåÅ‰ªìÊÄªÂ∏ÇÂÄº
        double totalMarketValue = x.get().marketValue;


        for (BtPositionRecordDO positionRecordDO : x.get().positionRecordDOList) {


            String stockCode = positionRecordDO.getStockCode();
            double marketValue = positionRecordDO.getMarketValue().doubleValue();
            int quantity = positionRecordDO.getQuantity();


            // ---------------------------------------------------------------


            // ‰∏™ËÇ° Âáè‰ªìÈáëÈ¢ù  =  ‰∏™ËÇ° Â∏ÇÂÄºÂç†ÊØî  x  Âáè‰ªìÊÄªÈáëÈ¢ù
            double stock_reduction_amount = marketValue / totalMarketValue * total_reduction_amount;
//            Assert.isTrue(stock_reduction_amount <= marketValue,
//                          String.format("Ë∂ÖÂçñÔºö‰∏™ËÇ°Âáè‰ªìÈáëÈ¢ù[%s] > ‰∏™ËÇ°Â∏ÇÂÄº[%s]", stock_reduction_amount, marketValue));


            BtTradeRecordDO sell_tradeRecordDO = new BtTradeRecordDO();
            sell_tradeRecordDO.setTaskId(taskId);
            sell_tradeRecordDO.setTradeType(BtTradeTypeEnum.SELL.getTradeType());
            sell_tradeRecordDO.setStockId(data.stock__codeIdMap.get(stockCode));
            sell_tradeRecordDO.setStockCode(stockCode);
            sell_tradeRecordDO.setStockName(data.stock__codeNameMap.get(stockCode));

            sell_tradeRecordDO.setTradeDate(tradeDate);
            // sell_tradeRecordDO.setTradeSignal(sell_infoMap.get(stockCode));
            // sell_tradeRecordDO.setTradeSignal("Â§ßÁõò‰ªì‰ΩçÈôêÂà∂->Á≠âÊØîÂáè‰ªì");
            sell_tradeRecordDO.setTradeSignalType(SellStrategyEnum.S21.getType());
            sell_tradeRecordDO.setTradeSignalDesc(SellStrategyEnum.S21.getDesc());


            double closePrice = getClosePrice(stockCode, tradeDate);
            sell_tradeRecordDO.setPrice(NumUtil.double2Decimal(closePrice));


            int qty = (int) (stock_reduction_amount / closePrice);
            // ‰∏çËÉΩË∂ÖÂçñ
            qty = Math.min(qty, quantity);
            sell_tradeRecordDO.setQuantity(qty);


            // Êàê‰∫§È¢ù = ‰ª∑Ê†º x Êï∞Èáè
            double amount = sell_tradeRecordDO.getPrice().doubleValue() * sell_tradeRecordDO.getQuantity();
            sell_tradeRecordDO.setAmount(of(amount));


            // ‰ªì‰ΩçÂç†ÊØî = ÊåÅ‰ªìÂ∏ÇÂÄº / ÊÄªËµÑÈáë
            double positionPct = amount / x.get().capital * 100;
            sell_tradeRecordDO.setPositionPct(of(positionPct));

            sell_tradeRecordDO.setFee(BigDecimal.ZERO);


            btTradeRecordService.retryBatchSave(Lists.newArrayList(sell_tradeRecordDO));
        }
    }


    // ------------------------------------------------------- B -------------------------------------------------------


    /**
     * BÁ≠ñÁï• - SÁ≠ñÁï•   Áõ∏‰∫íÂÜ≤Á™Åbug       =>       ‰ª• SÁ≠ñÁï• ‰∏∫ÂáÜ       ->       Âá∫Áé∞ S‰ø°Âè∑ ‰∏™ËÇ°‰∏çËÉΩ‰π∞ÂÖ•ÔºàbuyList -> ÂâîÈô§Ôºâ
     *
     * @param topBlockStrategyEnum
     * @param data
     * @param tradeDate
     * @param buy__stockCodeList
     */
    @TotalTime
    public void buy_sell__signalConflict(TopBlockStrategyEnum topBlockStrategyEnum,
                                         BacktestCache data,
                                         LocalDate tradeDate,
                                         List<String> buy__stockCodeList) {


        Map<String, SellStrategyEnum> sell_infoMap = Maps.newHashMap();


        // ÂΩìÂâç buyList   ->   ÊòØÂê¶ ‰∏é SÁ≠ñÁï• Áõ∏‰∫íÂÜ≤Á™Å       =>       ËøáÊª§Âá∫ ÂÜ≤Á™Å‰∏™ËÇ°ÔºàsellListÔºâ
        Set<String> sell__stockCodeSet = sellStrategyFactory.get("A").rule(topBlockStrategyEnum, data, tradeDate, buy__stockCodeList, sell_infoMap);


        // buyList   ->   remove  ÂÜ≤Á™Å‰∏™ËÇ°ÔºàsellListÔºâ
        buy__stockCodeList.removeAll(sell__stockCodeSet);


        if (CollectionUtils.isNotEmpty(buy__stockCodeList)) {

            log.warn("buy_sell__signalConflict  -  remove BSÂÜ≤Á™Å‰∏™ËÇ°     >>>     taskId : {} , tradeDate : {} , sell__stockCodeSet : {} , sell_infoMap : {} , new__buy__stockCodeList : {}",
                     x.get().taskId, x.get().tradeDate, JSON.toJSONString(sell__stockCodeSet), JSON.toJSONString(sell_infoMap), JSON.toJSONString(buy__stockCodeList));
        }
    }


    /**
     * BÁ≠ñÁï•   ->   BUY TradeRecord
     *
     * @param taskId
     * @param tradeDate
     * @param buy__stockCodeList
     * @param buy_infoMap
     */
    private void createAndSave__BUY_TradeRecord(Long taskId,
                                                LocalDate tradeDate,
                                                List<String> buy__stockCodeList,
                                                Map<String, String> buy_infoMap) {


        int size_B = buy__stockCodeList.size();
        if (size_B == 0) {
            return;
        }


        log.debug("BÁ≠ñÁï• -> ‰∫§Êòì record - end     >>>     [{}] [{}] , prevAvlCapital : {} , sellCapital : {} , avlCapital : {} , prevCapital : {} , buyCapital : {}",
                  taskId, tradeDate, x.get().prevAvlCapital, x.get().sellCapital, x.get().avlCapital, x.get().prevCapital, x.get().buyCapital);


        // ------------------------------------------


        // Á≠âÊØî‰π∞ÂÖ•
        BigDecimal avg_amount = of(x.get().actAvlCapital / size_B);
        // Âçï‰∏Ä‰∏™ËÇ°   ÂçïÊ¨°ÊúÄÂ§ß‰π∞ÂÖ•  Ââ©‰ΩôËµÑÈáë x 10%
        avg_amount = avg_amount.min(of(x.get().actAvlCapital * 0.1));       // ÂèØÁî®ËµÑÈáë * 10%


        // Âçï‰∏Ä‰∏™ËÇ°   ÊúÄÂ§ß‰ªì‰ΩçÈôêÂà∂  =  ÊÄªËµÑÈáë x 10%
        double amount_limit = x.get().capital * 0.10;      // ÊÄªËµÑÈáë * 10%


        // ------------------------------------------


        // BÁ≠ñÁï•   ->   BUY TradeRecord
        List<BtTradeRecordDO> buy__tradeRecordDO__List = Lists.newArrayList();


        for (String stockCode : buy__stockCodeList) {


            // ÂΩìÂâç  ÂæÖ‰π∞ÂÖ•‰∏™ËÇ°  Â∏ÇÂÄºÔºàÂ¶ÇÊûú Ê≠§ÂâçÂ∑≤ÊåÅÊúâ ËØ•‰∏™ËÇ°Ôºâ
            double marketValue = Optional.ofNullable(x.get().stockCode_positionDO_Map.get(stockCode)).map(e -> e.getMarketValue().doubleValue()).orElse(0.0);


            // ÂèØ‰π∞‰ªì‰Ωç  =  ÊúÄÂ§ß‰ªì‰ΩçÈôêÂà∂ - ‰∏™ËÇ°Â∏ÇÂÄº
            double amount = amount_limit - marketValue;
            if (amount <= 0) {
                continue;
            } else {
                amount = Math.min(amount, avg_amount.doubleValue());
            }


            // -----------------------------------------------------------


            BtTradeRecordDO tradeRecordDO = new BtTradeRecordDO();
            tradeRecordDO.setTaskId(taskId);
            tradeRecordDO.setTradeType(BtTradeTypeEnum.BUY.getTradeType());
            tradeRecordDO.setStockId(data.stock__codeIdMap.get(stockCode));
            tradeRecordDO.setStockCode(stockCode);
            tradeRecordDO.setStockName(data.stock__codeNameMap.get(stockCode));
            tradeRecordDO.setTradeDate(tradeDate);
            // tradeRecordDO.setTradeSignal(buy_infoMap.get(stockCode));
            tradeRecordDO.setTradeSignalType(1);
            tradeRecordDO.setTradeSignalDesc(buy_infoMap.get(stockCode));

            // Êî∂Áõò‰ª∑
            BigDecimal close = NumUtil.double2Decimal(getClosePrice(stockCode, tradeDate));
            tradeRecordDO.setPrice(close);

            // ‰π∞ÂÖ•Êï∞Èáè   =   ÂèØ‰π∞‰ªì‰Ωç / Êî∂Áõò‰ª∑                                  ÔºàÂøΩÁï• üê∂üí©ÂÖ±‰∫ß‰∏ª‰πâÁâπËâ≤   ->   100ËÇ° bugÔºâ
            double qty = amount / close.doubleValue();
            tradeRecordDO.setQuantity((int) qty);

            // Êàê‰∫§È¢ù = ‰ª∑Ê†º x Êï∞Èáè
            tradeRecordDO.setAmount(of(amount));

            // ‰ªì‰ΩçÂç†ÊØî = ÊåÅ‰ªìÂ∏ÇÂÄº / ÊÄªËµÑÈáë
            double positionPct = amount / x.get().capital * 100;
            tradeRecordDO.setPositionPct(of(positionPct));

            tradeRecordDO.setFee(BigDecimal.ZERO);


            // ‰π∞ÂÖ•0ËÇ°Ôºà     amount -> (0,1)     Ôºâ
            if (qty < 1) {
                continue;
            }


            buy__tradeRecordDO__List.add(tradeRecordDO);
        }


        btTradeRecordService.retryBatchSave(buy__tradeRecordDO__List);
    }


    // ------------------------------------------------------ Â§ßÁõò ------------------------------------------------------


    /**
     * Â§ßÁõòÈáèÂåñ   ->   ÊÄª‰ªì‰Ωç ÈôêÂà∂
     *
     * @param tradeDate
     */
    private void market__position_limit(LocalDate tradeDate) {

        QaMarketMidCycleDO marketInfo = data.marketCache.get(tradeDate, k -> marketService.marketInfo(tradeDate));
        Assert.notNull(marketInfo, "[Â§ßÁõòÈáèÂåñ]Êï∞ÊçÆ‰∏∫Á©∫Ôºö" + tradeDate);


        // ÊÄª‰ªì‰Ωç - %‰∏äÈôê
        double positionPct = marketInfo.getPositionPct().doubleValue();
        x.get().positionLimitRate = positionPct == 0 ? 0 : positionPct / 100;
    }


    // --------------------------------------------------- statData ----------------------------------------------------


    /**
     * SELL - before        =>      ËÆ°ÁÆó ÊÄªËµÑÈáë
     */
    private void sell_before___statData___step1__init() {


        // Ëé∑Âèñ -> ÊåÅ‰ªìÂàóË°®
        List<BtPositionRecordDO> positionRecordDOList = getDailyPositions(x.get().taskId, x.get().tradeDate);


        // ËÆ°ÁÆó
        CalcStat calcStat = new CalcStat(positionRecordDOList, null);


        // ------------------------------------------------------------------------

        // copyË¶ÜÁõñ
        // BeanUtils.copyProperties(calcStat, x.get());


        x.get().positionRecordDOList = positionRecordDOList;
        x.get().positionStockCodeList = calcStat.getPositionStockCodeList();
        x.get().stockCode_positionDO_Map = calcStat.getStockCode_positionDO_Map();


        // ------------------------------------------------------------------------


        // ÂΩìÂâç ÊÄªÂ∏ÇÂÄº   =   SÂâç ÊÄªÂ∏ÇÂÄº
        x.get().marketValue = calcStat.getMarketValue();

        // SÂâç ÂèØÁî®ËµÑÈáë   =   Êò®Êó• ÂèØÁî®ËµÑÈáë
        x.get().avlCapital = x.get().prevAvlCapital;


        // ---------------------------------------------------------- ‰∏çÂèò


        // SÂâç ÊÄªËµÑÈáë   =   SÂâç ÊÄªÂ∏ÇÂÄº  +  SÂâç ÂèØÁî®ËµÑÈáë
        x.get().capital = x.get().marketValue + x.get().avlCapital;
        log.debug("init capital   -   [{}] [{}]     >>>     capital : {} , marketValue : {} , avlCapital : {}",
                  x.get().taskId, x.get().tradeDate, x.get().capital, x.get().marketValue, x.get().avlCapital);


        // ---------------------------------------------------------- ‰∏çÂèò


        // ‰ªì‰ΩçÊÄªÈáëÈ¢ù ‰∏äÈôê   =   ÊÄªËµÑÈáë  x  ‰ªì‰ΩçÁôæÂàÜÊØî ‰∏äÈôê
        x.get().positionLimitAmount = x.get().capital * x.get().positionLimitRate;


        // ÂΩìÂâç ÂÆûÈôÖÂèØÁî®ËµÑÈáëÔºàÁ≠ñÁï• -> ‰ªì‰ΩçÈôêÂà∂Ôºâ  =   ‰ªì‰ΩçÊÄªÈáëÈ¢ù_‰∏äÈôê   -   ÊåÅ‰ªìÊÄªÂ∏ÇÂÄº
        x.get().actAvlCapital = x.get().positionLimitAmount - x.get().marketValue;
    }


    // --------------------------------------------------- statData ----------------------------------------------------


    /**
     * refresh  ->  statData
     */
    private void refresh_statData() {
        // Ëé∑Âèñ  ->  ÂΩìÂâç ÊåÅ‰ªìÂàóË°®
        List<BtPositionRecordDO> positionRecordDOList = getDailyPositions(x.get().taskId, x.get().tradeDate);
        // Ëé∑Âèñ  ->  ‰ªäÊó• B/SËÆ∞ÂΩï
        List<BtTradeRecordDO> tradeRecordDOList = btTradeRecordService.listByTaskIdAndTradeDate(x.get().taskId, x.get().tradeDate);


        // ËÆ°ÁÆó
        CalcStat calcStat = new CalcStat(positionRecordDOList, tradeRecordDOList);
        // copyË¶ÜÁõñ
        BeanUtils.copyProperties(calcStat, x.get());
    }


    // --------------------------------------------------- statData ----------------------------------------------------


    /**
     * prev ËµãÂÄº
     */
    private void refresh_statData__prev() {

        Stat x_copy = new Stat();
        BeanUtils.copyProperties(x.get(), x_copy);


        // 1„ÄÅÊ∏ÖÁ©∫
        x.remove();


        // 2„ÄÅtoday -> pre
        x.get().prevCapital = x_copy.capital;
        x.get().prevAvlCapital = x_copy.avlCapital;
        // x.get().prevPositionRecordDOList = x_copy.positionRecordDOList;
        x.get().prev__stockCode_positionDO_Map = x_copy.stockCode_positionDO_Map;


        x.get().taskId = x_copy.taskId;
    }


    // -----------------------------------------------------------------------------------------------------------------


    public LocalDate tradeDateIncr(LocalDate tradeDate) {
        Integer idx = data.dateIndexMap.get(tradeDate);

        // Èùû‰∫§ÊòìÊó•
        while (idx == null) {
            // ‰∏ã‰∏ÄËá™ÁÑ∂Êó•   ->   Áõ¥Ëá≥ ‰∫§ÊòìÊó•
            tradeDate = tradeDate.plusDays(1);
            idx = data.dateIndexMap.get(tradeDate);


            if (!DateTimeUtil.between(tradeDate, data.startDate(), data.endDate())) {
                throw new BizException(String.format("[Êó•ÊúüÔºö%s]ÈùûÊ≥ïÔºåË∂ÖÂá∫ÊúâÊïà‰∫§ÊòìÊó•ËåÉÂõ¥", tradeDate));
            }
        }


        // ‰∏ã‰∏Ä‰∏™
        return data.dateList.get(idx + 1);
    }

    public LocalDate tradeDateDecr(LocalDate tradeDate) {
        Integer idx = data.dateIndexMap.get(tradeDate);

        // Èùû‰∫§ÊòìÊó•
        while (idx == null) {
            // ‰∏ä‰∏ÄËá™ÁÑ∂Êó•   ->   Áõ¥Ëá≥ ‰∫§ÊòìÊó•
            tradeDate = tradeDate.minusDays(1);
            idx = data.dateIndexMap.get(tradeDate);


            if (!DateTimeUtil.between(tradeDate, data.startDate(), data.endDate())) {
                throw new BizException(String.format("[Êó•ÊúüÔºö%s]ÈùûÊ≥ïÔºåË∂ÖÂá∫ÊúâÊïà‰∫§ÊòìÊó•ËåÉÂõ¥", tradeDate));
            }
        }


        // ‰∏ä‰∏Ä‰∏™
        return data.dateList.get(idx - 1);
    }


    /**
     * ËÆ°ÁÆó  ->  ÊØèÊó•Êî∂ÁõäÁéá
     *
     * @param taskId
     * @param initialCapital       Êú¨Èáë
     * @param avlCapital
     * @param buyCapital
     * @param sellCapital
     * @param tradeDate            ÂΩìÂâç ‰∫§ÊòìÊó•
     * @param positionRecordDOList ÂΩìÂâç ÊåÅ‰ªìÂàóË°®
     */
    private void calcDailyReturn(Long taskId,
                                 BigDecimal initialCapital,
                                 double prevCapital,
                                 double avlCapital, double buyCapital, double sellCapital,
                                 LocalDate tradeDate,
                                 List<BtPositionRecordDO> positionRecordDOList) {


        // ÂΩìÊó• ÊåÅ‰ªìÂ∏ÇÂÄº   =   ‰∏™ËÇ°Â∏ÇÂÄº   Ê±áÊÄª
        BigDecimal marketValue = positionRecordDOList.stream()
                                                     .map(BtPositionRecordDO::getMarketValue)
                                                     .reduce(BigDecimal.ZERO, BigDecimal::add);

        if (!TdxFunCheck.equals(marketValue, x.get().marketValue)) {
            log.warn("calcDailyReturn - err     >>>     [{}] [{}] , marketValue : {} , x.marketValue : {}",
                     taskId, tradeDate, marketValue, x.get().marketValue);
        }


        // ÊÄªËµÑÈáë  =  ÊåÅ‰ªìÂ∏ÇÂÄº + ÂèØÁî®ËµÑÈáë
        BigDecimal capital = marketValue.add(of(avlCapital));

        if (!TdxFunCheck.equals(capital, x.get().capital)) {
            log.warn("calcDailyReturn - err     >>>     [{}] [{}] , capital : {} , x.capital : {}",
                     taskId, tradeDate, capital, x.get().capital);
        }


        if (!TdxFunCheck.equals(avlCapital, x.get().avlCapital)) {
            log.warn("calcDailyReturn - err     >>>     [{}] [{}] , avlCapital : {} , x.avlCapital : {}",
                     taskId, tradeDate, avlCapital, x.get().avlCapital);
        }


        // ‰ªì‰ΩçÂç†ÊØî = ÊåÅ‰ªìÂ∏ÇÂÄº / ÊÄªËµÑÈáë
        BigDecimal positionPct = marketValue.divide(capital, 8, RoundingMode.HALF_UP).multiply(BigDecimal.valueOf(100));


        // ÂáÄÂÄº = ÊÄªËµÑÈáë / Êú¨Èáë
        BigDecimal nav = capital.divide(initialCapital, 8, RoundingMode.HALF_UP);

        // ÂΩìÊó•Áõà‰∫èÈ¢ù = ÂΩìÊó•ÊÄªËµÑÈáë - Êò®Êó•ÊÄªËµÑÈáë
        BigDecimal profitLossAmount = capital.subtract(of(prevCapital));

        // ÂΩìÊó•Êî∂ÁõäÁéá = ÂΩìÊó•ÊÄªËµÑÈáë / Êò®Êó•ÊÄªËµÑÈáë - 1
        // BigDecimal dailyReturn = capital.divide(prevCapital, 6, RoundingMode.HALF_UP).subtract(BigDecimal.ONE);

        // ÂΩìÊó•Êî∂ÁõäÁéá = ÂΩìÊó•Áõà‰∫èÈ¢ù / Êò®Êó•ÊÄªËµÑÈáë
        BigDecimal dailyReturn = profitLossAmount.divide(of(prevCapital), 6, RoundingMode.HALF_UP);
        log.debug("calcDailyReturn     >>>     [{}] [{}] , marketValue : {} , avlCapital : {} , capital : {} , prevCapital : {} , profitLossAmount : {} , dailyReturn : {} , nav : {}",
                  taskId, tradeDate, marketValue, avlCapital, capital, prevCapital, profitLossAmount, dailyReturn, nav);


        BtDailyReturnDO dailyReturnDO = new BtDailyReturnDO();
        dailyReturnDO.setTaskId(taskId);
        // Êó•Êúü
        dailyReturnDO.setTradeDate(tradeDate);
        // ÂΩìÊó•Êî∂ÁõäÁéá
        dailyReturnDO.setDailyReturn(dailyReturn);
        // ÂΩìÊó•Áõà‰∫èÈ¢ù
        dailyReturnDO.setProfitLossAmount(profitLossAmount);
        // ÂáÄÂÄº
        dailyReturnDO.setNav(nav);
        // ÊÄªËµÑÈáë
        dailyReturnDO.setCapital(capital);
        // ÊåÅ‰ªìÂ∏ÇÂÄº
        dailyReturnDO.setMarketValue(marketValue);
        // ‰ªì‰ΩçÂç†ÊØîÔºà%Ôºâ
        dailyReturnDO.setPositionPct(positionPct);
        // ‰ªì‰Ωç‰∏äÈôêÂç†ÊØîÔºà%Ôºâ
        dailyReturnDO.setPositionLimitPct(of(x.get().positionLimitRate * 100));
        // ÂèØÁî®ËµÑÈáë
        dailyReturnDO.setAvlCapital(of(avlCapital));
        // ‰π∞ÂÖ•ÈáëÈ¢ù
        dailyReturnDO.setBuyCapital(of(buyCapital));
        // ÂçñÂá∫ÈáëÈ¢ù
        dailyReturnDO.setSellCapital(of(sellCapital));

        // Âü∫ÂáÜÊî∂ÁõäÔºàÊ≤™Ê∑±300Ôºâ
        dailyReturnDO.setBenchmarkReturn(null);


        btDailyReturnService.retrySave(dailyReturnDO);
    }


    /**
     * Ê±áÊÄªËÆ°ÁÆó -> ÊÄªÊî∂Áõä
     *
     * @param taskDO
     */
    private void sumTotalReturn(BtTaskDO taskDO) {


        // ÂÖ®ÊúüÊ±áÊÄªÔºöÊõ¥Êñ∞ bt_task


        // ÂÖ®Èáè  ÊØèÊó•Êî∂Áõä-ËÆ∞ÂΩï
        List<BtDailyReturnDO> dailyReturnDOList = btDailyReturnService.listByTaskId(x.get().taskId);


        // ÊúÄÂ§ßÂõûÊí§
        DrawdownResult drawdownResult = calcMaxDrawdown(dailyReturnDOList);


        // ÊØèÊó•Êî∂ÁõäÁéá ÂàóË°®
        List<BigDecimal> dailyReturnList = drawdownResult.dailyReturnList;


        // ------------------------------------------------------


        // ‰∫§ÊòìËÉúÁéá
        TradePairStat.TradeStatResult tradeStatResult = tradePairStat.calcTradeWinPct(tradeRecordList__cache.get());

        // task ‰∫§ÊòìËÉúÁéá
        double winRate = tradeStatResult.getWinPct();
        // ‰∏™ËÇ° ‰∫§ÊòìËÉúÁéá
        List<TradePairStat.StockStat> stockStatList = tradeStatResult.getStockStatList();


        // ------------------------------------------------------


        // ÊÄªÂ§©Êï∞ÔºàÊåÅ‰ªìÂ§©Êï∞Ôºâ   ->   Èó¥Èöî  N‰∏™‰∫§ÊòìÊó•
        int totalDays = dailyReturnDOList.size();


        // final  ->  Last
        BtDailyReturnDO finalReturn = dailyReturnDOList.get(dailyReturnDOList.size() - 1);
        BigDecimal finalNav = finalReturn.getNav();
        BigDecimal finalCapital = finalReturn.getCapital();


        // ÂáÄÂÄºÂ¢ûÂπÖ =  ÊúüÊú´ÂáÄÂÄº - ÂàùÂßãÂáÄÂÄºÔºà1Ôºâ
        BigDecimal totalReturn = finalNav.subtract(BigDecimal.ONE);
        // ÊÄªÊî∂ÁõäÁéáÔºà%Ôºâ =  ÂáÄÂÄºÂ¢ûÂπÖ x 100%
        BigDecimal totalReturnPct = totalReturn.multiply(of(100));
        // Âπ¥ÂåñÊî∂ÁõäÁéáÔºà%Ôºâ = ÔºàÊúüÊú´ÂáÄÂÄº / ÂàùÂßãÂáÄÂÄºÔºâ^(252 / ÊÄªÂ§©Êï∞) - 1          x 100%
        BigDecimal annualReturnPct = of(Math.pow(finalNav.doubleValue(), 252.0 / totalDays) - 1).multiply(of(100));


        // Â§èÊôÆÊØîÁéá = Âπ≥ÂùáÊó•Êî∂Áõä / Êó•Êî∂ÁõäÊ†áÂáÜÂ∑Æ * sqrt(252)
        double mean = dailyReturnList.stream().mapToDouble(BigDecimal::doubleValue).average().orElse(0);
        double sd = Math.sqrt(dailyReturnList.stream().mapToDouble(r -> Math.pow(r.doubleValue() - mean, 2)).sum() / dailyReturnList.size());
        BigDecimal sharpe = of(mean / sd * Math.sqrt(252));


        // ÁõàÂà©Â§©Êï∞ Âç†ÊØî  =  ÁõàÂà©Â§©Êï∞ / ÊÄªÂ§©Êï∞
        BigDecimal profitDayPct = of((double) drawdownResult.profitDayCount / totalDays * 100);


        // Áõà‰∫èÊØî = ÊâÄÊúâÁõàÂà©Êó•Âπ≥ÂùáÊî∂Áõä / ÊâÄÊúâ‰∫èÊçüÊó•Âπ≥Âùá‰∫èÊçü
        double avgWin = dailyReturnList.stream().filter(r -> r.doubleValue() > 0).mapToDouble(BigDecimal::doubleValue).average().orElse(0);
        double avgLoss = dailyReturnList.stream().filter(r -> r.doubleValue() < 0).mapToDouble(BigDecimal::doubleValue).map(Math::abs).average().orElse(0);

        BigDecimal profitFactor = avgLoss == 0 ? of(Double.POSITIVE_INFINITY) : of(avgWin / avgLoss);


        // ------------------------------------------------ Êõ¥Êñ∞ bt_task


        taskDO.setTotalTrade(tradeStatResult.totalPairs);
        taskDO.setTotalTradeAmount(NumUtil.double2Decimal(tradeStatResult.totalAmount));
        taskDO.setStatus(2);


        taskDO.setFinalCapital(finalCapital);
        taskDO.setFinalNav(finalNav);
        taskDO.setTotalDay(totalDays);
        taskDO.setTotalReturnPct(totalReturnPct);
        taskDO.setAnnualReturnPct(annualReturnPct);
        taskDO.setWinPct(of(winRate));
        taskDO.setProfitFactor(profitFactor);
        taskDO.setMaxDrawdownPct(drawdownResult.drawdownPct);
        taskDO.setProfitDayPct(profitDayPct);
        taskDO.setSharpeRatio(sharpe);


        // result - JSONËØ¶ÊÉÖ
        taskDO.setTradeStatResult(JSON.toJSONString(tradeStatResult));
        taskDO.setDrawdownResult(JSON.toJSONString(drawdownResult));


        btTaskService.updateById(taskDO);
    }


    public DrawdownResult calcMaxDrawdown(List<BtDailyReturnDO> list) {

        DrawdownResult result = new DrawdownResult();
        result.drawdownPct = BigDecimal.ZERO;


        // -------------------------


        // Ê≥¢Â≥∞ tmp
        BigDecimal peakNav = BigDecimal.ZERO;
        LocalDate peakDate = null;


        // --------------------------------------------------


        for (BtDailyReturnDO rec : list) {
            BigDecimal nav = rec.getNav();
            LocalDate date = rec.getTradeDate();


            // ÂΩìÊó•Âàõ ÊúÄÂ§ßÂáÄÂÄº   ->   Êñ∞ Ê≥¢Â≥∞
            if (nav.compareTo(peakNav) > 0) {
                // Ê≥¢Â≥∞
                peakNav = nav;
                peakDate = date;
            }


            // ÂΩìÊó•Ë∑åÂπÖ  = ÔºàÂáÄÂÄº - Ê≥¢Â≥∞Ôºâ/ Ê≥¢Â≥∞
            BigDecimal ddPct = nav.subtract(peakNav).divide(peakNav, 6, RoundingMode.HALF_UP).multiply(of(100));


            // ÂΩìÊó•Âàõ ÊúÄÂ§ßË∑åÂπÖ   ->   Êñ∞ Ê≥¢Ë∞∑
            if (ddPct.compareTo(result.drawdownPct) < 0) {

                // Ê≥¢Ë∞∑
                result.drawdownPct = ddPct;
                result.troughDate = date;
                result.troughNav = nav;

                // Ê≥¢Â≥∞
                result.peakDate = peakDate;
                result.peakNav = peakNav;
            }


            // Ê±áÊÄªÁªüËÆ° - ÊåáÊ†áÊõ¥Êñ∞


            // -------------------------


            // ÁõàÂà©Â§©Êï∞
            if (rec.getDailyReturn().doubleValue() > 0) {
                result.profitDayCount++;
            }


            // -------------------------


            // ÊØèÊó•Êî∂ÁõäÁéá
            result.dailyReturnList.add(rec.getDailyReturn());
        }


        return result;
    }


    /**
     * Ëé∑Âèñ ÊüêÂõûÊµã‰ªªÂä° Âú®ÊåáÂÆöÊó•ÊúüÁöÑ   ÊåÅ‰ªìËØ¶ÊÉÖ
     *
     * @param taskId
     * @param endTradeDate ÁªüËÆ° Êà™Ê≠¢Êó•Êúü
     * @return
     */
    private List<BtPositionRecordDO> getDailyPositions(Long taskId, LocalDate endTradeDate) {


        // -------------------------------------------------------------------------------------------------------------


        // 1„ÄÅÂÖ®Èáè B/SËÆ∞ÂΩï     =>     ÂΩìÂâçB/SÔºàÊú™Ê∏Ö‰ªìÔºâ   +   ÂéÜÂè≤B/SÔºàÂ∑≤Ê∏Ö‰ªìÔºâ


        // ÊØèÊ¨°  ->  Â¢ûÈáèÊü•ËØ¢     +     ÂéÜÂè≤ËÆ∞ÂΩïÔºàcacheÔºâ


        List<BtTradeRecordDO> incrQuery_tradeRecordList = btTradeRecordService.listByTaskIdAndTradeDate(taskId, endTradeDate);


        incrQuery_tradeRecordList.forEach(e -> {

            if (tradeRecord___idSet__cache.get().add(e.getId())) {
                // TODO ‰ºòÂåñ   ->   DELÈÖçÂØπÂéÜÂè≤ËÆ∞ÂΩïÔºà < ÊåÅ‰ªìËÆ∞ÂΩï buyDateÔºâ
                tradeRecordList__cache.get().add(e);
            }
        });


        // -------------------------------------------------------------------------------------------------------------


        // 2„ÄÅÂâîÈô§   ->   ÂéÜÂè≤B/SÔºàÂ∑≤Ê∏Ö‰ªìÔºâ


        // ÂΩìÊó•ÊåÅ‰ªìÔºà‰π∞ÂÖ•ËÆ∞ÂΩïÔºâÂàóË°®   ->   ÂΩìÂâçB/SÔºàÊäµÊ∂àÂêé -> Êú™Ê∏Ö‰ªìÔºâ
        List<BtTradeRecordDO> todayHoldingList = Lists.newArrayList();
        // ÂΩìÊó•Ê∏Ö‰ªìÂàóË°®             ->   Ê∏Ö‰ªìstockCode - Ê∏Ö‰ªìÔºàÂçñÂá∫ËÆ∞ÂΩïÔºâ
        Map<String, BtTradeRecordDO> todayClearMap = Maps.newHashMap();
        Map<String, BtTradeRecordDO> todayBuyMap = Maps.newHashMap();


        // ÊåÅ‰ªìÂàóË°®„ÄÅÊ∏Ö‰ªìÂàóË°®
        holdingList__buyQueues__todayClearedCodes(endTradeDate, tradeRecordList__cache, todayHoldingList, todayClearMap, todayBuyMap);


        // todayHoldingList ‰∏≠Âç≥‰∏∫‚ÄúÂΩìÊó•Êú™Ê∏Ö‰ªì‚ÄùÁöÑ‰π∞ÂÖ•ËÆ∞ÂΩïÔºàquantity Â∑≤ÊòØÂâ©‰ΩôÈáèÔºâ


        // -------------------------------------------------------------------------------------------------------------


        // 3. Ê±áÊÄª‰π∞Âçñ
        Map<String, Integer> quantityMap = Maps.newHashMap();       // ‰∏™ËÇ°ÊåÅ‰ªì -   ÊÄªÊï∞Èáè
        Map<String, Integer> avlQuantityMap = Maps.newHashMap();    // ‰∏™ËÇ°ÊåÅ‰ªì - ÂèØÁî®Êï∞ÈáèÔºàT+1Ôºâ
        Map<String, Double> amountMap = Maps.newHashMap();          // ‰∏™ËÇ°ÊåÅ‰ªì -   ÊÄªÊàêÊú¨Ôºà‰π∞ÂÖ•‰ª∑Ê†º x ‰π∞ÂÖ•Êï∞Èáè   ->   Á¥ØÂä†Ôºâ

        Map<String, PositionInfo> codeInfoMap = Maps.newHashMap();  // ‰∏™ËÇ°ÊåÅ‰ªì - È¶ñÊ¨°‰π∞ÂÖ•Info


        // --------------------------------------------


        // ÊàêÊú¨ËÆ°ÁÆó
        quantityMap__avlQuantityMap__amountMap__codeInfoMap(endTradeDate, todayHoldingList, quantityMap, avlQuantityMap, amountMap, codeInfoMap);


        // -------------------------------------------------------------------------------------------------------------


        // 4. ÊûÑÈÄ† ÂΩìÊó•ÊåÅ‰ªì ÂØπË±°ÂàóË°®
        List<BtPositionRecordDO> positionRecordDOList = todayPositionRecordList(taskId, endTradeDate, quantityMap, avlQuantityMap, amountMap, codeInfoMap, todayBuyMap);


        // -------------------------------------------------------------------------------------------------------------


        // 5. ÊûÑÈÄ† ÂΩìÊó•Ê∏Ö‰ªì ÂØπË±°ÂàóË°®
        List<BtPositionRecordDO> todayClearPositionRecordDOList = todayClearPositionRecordList(taskId, endTradeDate, todayClearMap);
        x.get().clearPositionRecordDOList = todayClearPositionRecordDOList;
        // btPositionRecordService.saveBatch(todayClearPositionRecordDOList);


        // -------------------------------------------------------------------------------------------------------------


        return positionRecordDOList;
    }


    /**
     * ÊåÅ‰ªìÂàóË°®„ÄÅÊ∏Ö‰ªìÂàóË°®
     *
     * @param endTradeDate
     * @param tradeRecordList__cache
     * @param todayHoldingList       ÂΩìÊó•ÊåÅ‰ªìÔºà‰π∞ÂÖ•ËÆ∞ÂΩïÔºâÂàóË°®   ->   ÂΩìÂâçB/SÔºàÊäµÊ∂àÂêé -> Êú™Ê∏Ö‰ªìÔºâ
     * @param todayClearMap          ÂΩìÊó•Ê∏Ö‰ªìÂàóË°®             ->   Ê∏Ö‰ªìstockCode - Ê∏Ö‰ªìÔºàÂçñÂá∫ËÆ∞ÂΩïÔºâ
     * @param todayBuyMap
     */
    private void holdingList__buyQueues__todayClearedCodes(LocalDate endTradeDate,
                                                           ThreadLocal<List<BtTradeRecordDO>> tradeRecordList__cache,
                                                           List<BtTradeRecordDO> todayHoldingList,
                                                           Map<String, BtTradeRecordDO> todayClearMap,
                                                           Map<String, BtTradeRecordDO> todayBuyMap) {


        // ÊûÑÂª∫ FIFO ÈòüÂàóÔºöstockCode -> ÈòüÂàóÈáåÂ≠ò Ââ©‰ΩôÁöÑ‰π∞Âçï
        Map<String, Deque<MutableTrade>> buyQueues = new HashMap<>();


        // ÈÅçÂéÜÊâÄÊúâËÆ∞ÂΩïÔºåÊûÑÂª∫/ÊäµÈîÄ
        for (BtTradeRecordDO tr : tradeRecordList__cache.get()) {

            String code = tr.getStockCode();
            int qty = tr.getQuantity();


            if (Objects.equals(tr.getTradeType(), BtTradeTypeEnum.BUY.getTradeType())) {

                // ‰π∞ÂÖ•ÔºöÂÖ•Èòü
                buyQueues.computeIfAbsent(code, k -> new LinkedList<>()).addLast(new MutableTrade(tr, qty));

            } else {

                // ÂçñÂá∫ÔºöÁî® FIFO ÈòüÂ§¥‰π∞ÂçïÊäµÈîÄ
                Deque<MutableTrade> queue = buyQueues.get(code);
                int remaining = qty;
                while (remaining > 0 && queue != null && !queue.isEmpty()) {
                    MutableTrade head = queue.peekFirst();
                    if (head.remainingQty > remaining) {
                        head.remainingQty -= remaining;
                        remaining = 0;
                    } else {
                        remaining -= head.remainingQty;
                        queue.pollFirst(); // Ëøô‰∏™‰π∞ÂçïÂÆåÂÖ®ÊäµÈîÄ
                    }
                }


                // ÔºàÂèØÈÄâÔºâÂ¶ÇÊûú remaining>0ÔºåËØ¥ÊòéÂçñÁ©∫ÊàñË∂ÖÂçñÔºåÊåâ‰∏öÂä°Â§ÑÁêÜ
                // if (remaining > 0) {
                //     log.warn("Ë∂ÖÂçñ     >>>     ËÇ°Á•®[{}] ÂçñÂá∫[{}]ËÇ°ÔºåË∂ÖÂçñ[{}]ËÇ°", code, qty, remaining);
                // }


                // Â¶ÇÊûú ÂΩìÊó•ÂçñÂá∫ ÂØºËá¥ÊåÅ‰ªì‰∏∫0ÔºåÂàôËÆ∞ÂΩï Ê∏Ö‰ªìÊ†áËÆ∞
                if (tr.getTradeDate().isEqual(endTradeDate) && CollectionUtils.isEmpty(queue) /*&& remaining >= 0*/) {
                    todayClearMap.put(code, tr);
                }

                if (tr.getTradeDate().isEqual(endTradeDate) && CollectionUtils.isNotEmpty(queue) /*&& remaining >= 0*/) {
                    todayBuyMap.put(code, tr);
                }
            }
        }


        // ‰ªéÂêÑÈòüÂàóÈáåÊî∂ÈõÜÊâÄÊúâÂâ©‰ΩôÁöÑ‰π∞ÂçïÔºåËΩ¨Êç¢ÂõûÂéü DTO Âπ∂Êää quantity Ë∞ÉÊàêÂâ©‰ΩôÊï∞Èáè
        for (Deque<MutableTrade> queue : buyQueues.values()) {
            for (MutableTrade mt : queue) {

                BtTradeRecordDO openBuy = mt.original;
                // original Ââ©‰ΩôÊï∞Èáè   ->   ÊäµÊ∂àÂçñÂçïÂêéÁöÑ Ââ©‰ΩôÊï∞Èáè
                openBuy.setQuantity(mt.remainingQty);

                todayHoldingList.add(openBuy);
            }
        }
    }


    /**
     * ÊàêÊú¨ËÆ°ÁÆó
     *
     * @param endTradeDate     ÂΩìÂâç‰∫§ÊòìÊó•
     * @param todayHoldingList ÂΩìÊó•ÊåÅ‰ªìÔºà‰π∞ÂÖ•ËÆ∞ÂΩïÔºâÂàóË°®
     * @param quantityMap      ‰∏™ËÇ°ÊåÅ‰ªì -   ÊÄªÊï∞Èáè
     * @param avlQuantityMap   ‰∏™ËÇ°ÊåÅ‰ªì - ÂèØÁî®Êï∞ÈáèÔºàT+1Ôºâ
     * @param amountMap        ‰∏™ËÇ°ÊåÅ‰ªì -   ÊÄªÊàêÊú¨Ôºà‰π∞ÂÖ•‰ª∑Ê†º x ‰π∞ÂÖ•Êï∞Èáè   ->   Á¥ØÂä†Ôºâ
     * @param codeInfoMap      ‰∏™ËÇ°ÊåÅ‰ªì - È¶ñÊ¨°‰π∞ÂÖ•Info
     */
    private void quantityMap__avlQuantityMap__amountMap__codeInfoMap(LocalDate endTradeDate,
                                                                     List<BtTradeRecordDO> todayHoldingList,
                                                                     Map<String, Integer> quantityMap,
                                                                     Map<String, Integer> avlQuantityMap,
                                                                     Map<String, Double> amountMap,
                                                                     Map<String, PositionInfo> codeInfoMap) {


        for (BtTradeRecordDO tr : todayHoldingList) {


            Long stockId = tr.getStockId();
            String stockCode = tr.getStockCode();
            String stockName = tr.getStockName();

            // B/S
            Integer tradeType = tr.getTradeType();
            Integer quantity = tr.getQuantity();
            BigDecimal amount = tr.getAmount();

            // ‰∫§ÊòìÊó•Êúü
            LocalDate tradeDate = tr.getTradeDate();


            // ‰π∞ÂÖ•Á¥ØÂä† / ÂçñÂá∫Á¥ØÂáè   ->   ÊÄªÊï∞Èáè„ÄÅÊÄªÊàêÊú¨
            int sign = Objects.equals(BtTradeTypeEnum.BUY.getTradeType(), tradeType) ? +1 : -1;
            // ‰∏™ËÇ°ÊåÅ‰ªì - ÊÄªÊï∞Èáè
            quantityMap.merge(stockCode, sign * quantity, Integer::sum);
            // ‰∏™ËÇ°ÊåÅ‰ªì - ÊÄªÊàêÊú¨
            amountMap.merge(stockCode, sign * amount.doubleValue(), Double::sum);


            // T+1Ôºàüê∂üí©ÂÖ±‰∫ß‰∏ª‰πâÁâπËâ≤Ôºâ
            if (sign == 1 && tradeDate.isEqual(endTradeDate)) {
                // ‰ªäÊó•‰π∞ÂÖ•  =>  ÊòéÊó•ÊâçÂèØÂçñÔºà‰ªäÊó• ‰∏çÂèØÁî®  ->  +0 Ôºâ
                avlQuantityMap.merge(stockCode, 0, Integer::sum);
            } else {
                // ‰ªäÊó•ÂèØÁî®   ->   Ê≠£Â∏∏Á¥ØÂä†
                avlQuantityMap.merge(stockCode, sign * quantity, Integer::sum);
            }


            PositionInfo positionInfo = codeInfoMap.get(stockCode);
            if (positionInfo == null) {

                positionInfo = new PositionInfo(stockId, stockCode, stockName, tradeDate, tr.getPrice());
                codeInfoMap.put(stockCode, positionInfo);

            } else {


                // Êõ¥Êñ∞  ->  ÊúÄËøë‰∏ÄÊ¨°  È¶ñÊ¨°‰π∞ÂÖ•Êó•ÊúüÔºàÁî®‰∫éËÆ°ÁÆó ÊåÅ‰ªìÂ§©Êï∞Ôºâ     =>     ÊúÄËøë‰∏ÄÊ¨°  avlQuantity = 0
                if (avlQuantityMap.get(stockCode) == 0) {
                    // ÊúÄËøë‰∏ÄÊ¨°
                    LocalDate buyDate = tradeDate.isBefore(positionInfo.buyDate) ? tradeDate : positionInfo.buyDate;
                    positionInfo.setBuyDate(buyDate);
                    positionInfo.setInitBuyPrice(tr.getPrice());
                }
            }
        }

    }

    /**
     * ÊûÑÈÄ† ÂΩìÊó•ÊåÅ‰ªì ÂØπË±°ÂàóË°®
     *
     * @param taskId         ÂΩìÂâç‰ªªÂä°ID
     * @param endTradeDate   ÂΩìÂâç‰∫§ÊòìÊó•
     * @param quantityMap    ‰∏™ËÇ°ÊåÅ‰ªì -   ÊÄªÊï∞Èáè
     * @param avlQuantityMap ‰∏™ËÇ°ÊåÅ‰ªì - ÂèØÁî®Êï∞ÈáèÔºàT+1Ôºâ
     * @param amountMap      ‰∏™ËÇ°ÊåÅ‰ªì -   ÊÄªÊàêÊú¨Ôºà‰π∞ÂÖ•‰ª∑Ê†º x ‰π∞ÂÖ•Êï∞Èáè   ->   Á¥ØÂä†Ôºâ
     * @param codeInfoMap    ‰∏™ËÇ°ÊåÅ‰ªì - È¶ñÊ¨°‰π∞ÂÖ•Info
     * @param todayBuyMap
     * @return
     */
    private List<BtPositionRecordDO> todayPositionRecordList(Long taskId,
                                                             LocalDate endTradeDate,
                                                             Map<String, Integer> quantityMap,
                                                             Map<String, Integer> avlQuantityMap,
                                                             Map<String, Double> amountMap,
                                                             Map<String, PositionInfo> codeInfoMap,
                                                             Map<String, BtTradeRecordDO> todayBuyMap) {


        List<BtPositionRecordDO> positionRecordDOList = Lists.newArrayList();


        quantityMap.forEach((stockCode, qty) -> {

            // ÂΩìÊó•Êú™ÊåÅ‰ªì Êàñ Â∑≤ÂÖ®ÈÉ®ÂçñÂá∫
            if (qty <= 0) {
                return;
            }


            Integer avlQuantity = avlQuantityMap.getOrDefault(stockCode, 0);
            PositionInfo positionInfo = codeInfoMap.get(stockCode);


            // ÊÄªÊàêÊú¨
            double totalCost = amountMap.getOrDefault(stockCode, 0.0);
            // Âπ≥ÂùáÊàêÊú¨ = ÊÄªÊàêÊú¨ / ÊåÅ‰ªìÊï∞Èáè
            double avgCost = totalCost / qty;


            // ---------------------------------------------------------------------------------------------------------


            // ÊØèÊ¨°B/S   ->   ÊàêÊú¨/Êî∂Áõä/Êî∂ÁõäÁéá   ->   Áã¨Á´ã‰∫ã‰ª∂ÔºàËæπÁïåÔºâ     ==>     Âê¶ÂàôÔºå‰∏äÊ¨°B/S ‰∫èÊçü  ->  ÂêàÂπ∂ËÆ°ÂÖ•  Êú¨Ê¨°B/S   =>   ‰∫èÊçü -> Ë¥üÊï∞bugÔºàÊÄªÊàêÊú¨ Ë¥üÊï∞ -> Âπ≥ÂùáÊàêÊú¨ Ë¥üÊï∞Ôºâ     =>     Â∏ÇÂÄº ÁàÜÂáèbug
            if (avgCost < 0) {
                log.error("getDailyPositions - avgCost err     >>>     [{}] {} {} , totalCost : {} , qty : {} , avgCost : {}",
                          taskId, endTradeDate, stockCode, totalCost, qty, avgCost);
            }


            // ---------------------------------------------------------------------------------------------------------


            // ÂΩìÊó•Êî∂Áõò‰ª∑
            double closePrice = getClosePrice(stockCode, endTradeDate);


            // Á¥ØËÆ°ÊµÆÂä®Áõà‰∫è = ÔºàÂΩìÊó•Êî∂Áõò‰ª∑ - Âπ≥ÂùáÊàêÊú¨Ôºâx ÊåÅ‰ªìÊï∞Èáè
            double totalPnl = (closePrice - avgCost) * qty;

            // Á¥ØËÆ°ÊµÆÂä®Áõà‰∫èÁéáÔºà%Ôºâ
            double pnlPct = totalPnl * 100 / totalCost;


            // ---------------------------------------------------------------------------------------------------------
            //                                              ËÆ°ÁÆóÂΩìÊó•ÊµÆÂä®Áõà‰∫è
            // ---------------------------------------------------------------------------------------------------------


            double todayPnl = 0;
            double todayPnlPct = 0;


            double closeTodayReturnPct = 0;

            double priceTotalReturnPct = 0;
            double priceMaxReturnPct = 0;
            double priceMaxDrawdownPct = 0;


            // È¶ñÊ¨°‰π∞ÂÖ•‰ª∑Ê†º
            double initBuyPrice = positionInfo.initBuyPrice.doubleValue();


            // Êò®Êó•ÊåÅ‰ªìÊï∞Èáè„ÄÅÊàêÊú¨
            BtPositionRecordDO prevPos = x.get().prev__stockCode_positionDO_Map.get(stockCode);
            if (prevPos != null) {


                double prevAvgCostPrice = prevPos.getAvgCostPrice().doubleValue();
                double prevClosePrice = prevPos.getClosePrice().doubleValue();
                double prevQty = prevPos.getQuantity();
                double prevTotalCost = prevAvgCostPrice * prevQty;


                // -----------------------------------------------------------------------------------------------------


                // ‰ªäÊó•ÂçñÂá∫ -> ‰∏çÁî®ÁâπÊÆäÂ§ÑÁêÜÔºåÂõ†‰∏∫Á≥ªÁªüÁ∫¶ÂÆö‚ÄúÂçñÂá∫ = ÂÖ®ÈÉ®Ê∏Ö‰ªì‚ÄùÔºåÂõ†Ê≠§ qty Â∑≤Áªè‰ª£Ë°®ÂΩìÊó•ÊúÄÁªàÊåÅ‰ªì


                // Êò®Êó•ÊåÅ‰ªìÈÉ®ÂàÜÁöÑ ÂΩìÊó•ÊµÆÂä®Áõà‰∫è = (‰ªäÊó•Êî∂Áõò‰ª∑ - Êò®Êó•Êî∂Áõò‰ª∑) * Êò®Êó•ÊåÅ‰ªìÊï∞Èáè
                double pnlFromYesterday = (closePrice - prevClosePrice) * prevQty;


                // ‰ªäÊó•Êñ∞Â¢û‰π∞ÂÖ•ÈÉ®ÂàÜÁöÑÂΩìÊó•ÊµÆÂä®Áõà‰∫è = (‰ªäÊó•Êî∂Áõò‰ª∑ - ‰ªäÊó•‰π∞ÂÖ•‰ª∑) * ‰ªäÊó•‰π∞ÂÖ•Êï∞Èáè
                // Áî±‰∫éÊâÄÊúâ‰∫§ÊòìÈÉΩÂèëÁîüÂú®Êî∂Áõò‰ª∑ÔºåÂõ†Ê≠§‰ªäÊó•‰π∞ÂÖ•‰ª∑ = ‰ªäÊó•Êî∂Áõò‰ª∑ÔºåÂΩìÊó•ÊµÆÁõà=0
                double pnlFromTodayBuy = 0;


                // ÂΩìÊó•ÊµÆÂä®Áõà‰∫èÊÄªÈ¢ù
                todayPnl = pnlFromYesterday + pnlFromTodayBuy;


                // ÂΩìÊó•ÊµÆÂä®Áõà‰∫èÁéá = ÂΩìÊó•Áõà‰∫èÈ¢ù / Êò®Êó•ÊåÅ‰ªìÊàêÊú¨
                // ‚ö†Ô∏è Ê≥®ÊÑèÔºöÂàÜÊØçÂøÖÈ°ªÊòØÊò®Êó•ÁöÑÊàêÊú¨ÔºåËÄå‰∏çÊòØ‰ªäÊó•ÊÄªÊàêÊú¨ÔºåÂê¶Âàô‰ºöÁ®ÄÈáäÊéâÂΩìÊó•Áõà‰∫è
                // todayPnlPct = (prevTotalCost > 0) ? (todayPnl * 100 / prevTotalCost) : 0;


                // ÂΩìÊó•ÊµÆÂä®Áõà‰∫èÁéá = ÂΩìÊó•Áõà‰∫èÈ¢ù / ÊÄªÊàêÊú¨
                // ‚ö†Ô∏è Ê≥®ÊÑèÔºöÂàÜÊØçÂøÖÈ°ªÊòØ‰ªäÊó•ÁöÑÊÄªÊàêÊú¨Ôºå‰ªäÊó•Êñ∞‰π∞ÂÖ•  ->  ‰ºöÁ≠âÊØî‰æã Á®ÄÈáäÊéâÂΩìÊó•Áõà‰∫è
                todayPnlPct = (totalCost > 0) ? (todayPnl * 100 / totalCost) : 0;


                if (todayPnlPct > 30 || todayPnlPct < -30) {
                    log.error("todayPositionRecordList - err     >>>     taskId : {} , tradeDate : {} , stockCode : {}   ,   todayPnlPct : {} , todayPnl : {} ,totalCost : {} , prevPos : {} , todayTr : {}", taskId, endTradeDate, stockCode, todayPnlPct, todayPnl, totalCost, JSON.toJSONString(prevPos), JSON.toJSONString(todayBuyMap.get(stockCode)));

                    // TODO   ÂèëÁé∞Êúâ SÂêé Ââ©‰Ωô1ËÇ° bug
                    todayPnlPct = Math.min(todayPnlPct, 9999.99);
                    todayPnlPct = Math.max(todayPnlPct, -9999.99);
                }


                // -----------------------------------------------------------------------------------------------------


                // ÂΩìÊó•Ê∂®Ë∑åÂπÖÔºà%Ôºâ
                closeTodayReturnPct = (closePrice / prevClosePrice - 1) * 100;


                // È¶ñÊ¨°‰π∞ÂÖ•‰ª∑Ê†º-Á¥ØËÆ°Ê∂®ÂπÖÔºà%Ôºâ =  ÂΩìÊó•Êî∂Áõò‰ª∑ / initBuyPrice  - 1
                priceTotalReturnPct = (closePrice / initBuyPrice - 1) * 100;


                // Êò®Êó•-ÊúÄÂ§ßÊ∂®ÂπÖ
                priceMaxReturnPct = prevPos.getPriceMaxReturnPct().doubleValue();
                // Êò®Êó•-ÊúÄÂ§ßÂõûÊí§
                priceMaxDrawdownPct = prevPos.getPriceMaxDrawdownPct().doubleValue();


                // È¶ñÊ¨°‰π∞ÂÖ•‰ª∑Ê†º-ÊúÄÂ§ßÊ∂®ÂπÖÔºà%Ôºâ
                if (priceMaxReturnPct < priceTotalReturnPct) {
                    priceMaxReturnPct = priceTotalReturnPct;
                    // maxDate = tradeDate;
                }


                // ÂΩìÊó•ÂõûÊí§ÔºàË¥üÊï∞Ôºâ  =  ÔºàÂΩìÊó•ÔºâÁ¥ØËÆ°ÂáÄÂÄº / ÊúÄÂ§ßÂáÄÂÄº
                double drawdownPct = ((1 + priceTotalReturnPct * 0.01) / (1 + priceMaxReturnPct * 0.01) - 1) * 100;


                // È¶ñÊ¨°‰π∞ÂÖ•‰ª∑Ê†º-ÊúÄÂ§ßÂõûÊí§Ôºà%Ôºâ
                if (priceMaxDrawdownPct > drawdownPct) {
                    priceMaxDrawdownPct = drawdownPct;
                    // minDate = tradeDate;
                    // minNav = nav;
                }


            }


            // ---------------------------------------------------------------------------------------------------------


            BtPositionRecordDO positionRecordDO = new BtPositionRecordDO();

            positionRecordDO.setTaskId(taskId);
            positionRecordDO.setTradeDate(endTradeDate);
            positionRecordDO.setStockId(positionInfo.stockId);
            positionRecordDO.setStockCode(stockCode);
            positionRecordDO.setStockName(positionInfo.stockName);
            positionRecordDO.setAvgCostPrice(of(avgCost));
            positionRecordDO.setClosePrice(of(closePrice));
            // ÊåÅ‰ªìÊï∞Èáè
            positionRecordDO.setQuantity(qty);
            positionRecordDO.setAvlQuantity(avlQuantity);


            // ÂΩìÂâçÂ∏ÇÂÄº = ÊåÅ‰ªìÊï∞Èáè x ÂΩìÂâçÊî∂Áõò‰ª∑
            positionRecordDO.setMarketValue(of(qty * closePrice));

            // ‰ªì‰ΩçÂç†ÊØî = ÊåÅ‰ªìÂ∏ÇÂÄº / ÊÄªËµÑÈáë
            BigDecimal positionPct = positionRecordDO.getMarketValue().divide(of(x.get().capital), 8, RoundingMode.HALF_UP).multiply(BigDecimal.valueOf(100));
            positionRecordDO.setPositionPct(positionPct);


            // ÂΩìÊó•Áõà‰∫èÈ¢ù
            positionRecordDO.setCapTodayPnl(of(todayPnl));
            // ÂΩìÊó•Áõà‰∫èÁéáÔºà%Ôºâ
            positionRecordDO.setCapTodayPnlPct(of(todayPnlPct));

            // Á¥ØËÆ°Áõà‰∫èÈ¢ù
            positionRecordDO.setCapTotalPnl(of(totalPnl));
            // Á¥ØËÆ°Áõà‰∫èÁéáÔºà%Ôºâ = Áõà‰∫èÈ¢ù / ÊÄªÊàêÊú¨  x 100%
            positionRecordDO.setCapTotalPnlPct(of(pnlPct));


            // ÂΩìÊó•Ê∂®Ë∑åÂπÖÔºà%Ôºâ
            positionRecordDO.setChangePct(of(closeTodayReturnPct));

            // È¶ñÊ¨°‰π∞ÂÖ•‰ª∑Ê†º-Á¥ØËÆ°Ê∂®ÂπÖÔºà%Ôºâ
            positionRecordDO.setPriceTotalReturnPct(of(priceTotalReturnPct));
            // È¶ñÊ¨°‰π∞ÂÖ•‰ª∑Ê†º-ÊúÄÂ§ßÊ∂®ÂπÖÔºà%Ôºâ
            positionRecordDO.setPriceMaxReturnPct(of(priceMaxReturnPct));
            // È¶ñÊ¨°‰π∞ÂÖ•‰ª∑Ê†º-ÊúÄÂ§ßÂõûÊí§Ôºà%Ôºâ
            positionRecordDO.setPriceMaxDrawdownPct(of(priceMaxDrawdownPct));


            positionRecordDO.setBuyDate(positionInfo.buyDate);
            positionRecordDO.setHoldingDays(positionInfo.getHoldingDays(endTradeDate, data.dateIndexMap));
            positionRecordDO.setInitBuyPrice(positionInfo.initBuyPrice);


            // ---------------------------------------------------------------------------------------------------------


            if (null == positionRecordDO.getPriceMaxDrawdownPct()) {
                log.error("todayPositionRecordList - getPriceMaxDrawdownPct err     >>>     taskId : {} , tradeDate : {} , stockCode : {} , positionRecordDO : {}",
                          taskId, endTradeDate, stockCode, JSON.toJSONString(positionRecordDO));
            }


            // ÊåÅ‰ªìÁä∂ÊÄÅÔºö1-ÊåÅ‰ªì‰∏≠Ôºõ2-Â∑≤Ê∏Ö‰ªìÔºõ
            positionRecordDO.setPositionType(1);
            positionRecordDOList.add(positionRecordDO);
        });


        return positionRecordDOList;
    }


    /**
     * ÊûÑÈÄ† ÂΩìÊó•Ê∏Ö‰ªì ÂØπË±°ÂàóË°®
     *
     * @param taskId        ÂΩìÂâç‰ªªÂä°ID
     * @param endTradeDate  ÂΩìÂâç‰∫§ÊòìÊó•
     * @param todayClearMap ÂΩìÊó•Ê∏Ö‰ªìÂàóË°®             ->   Ê∏Ö‰ªìstockCode - Ê∏Ö‰ªìÔºàÂçñÂá∫ËÆ∞ÂΩïÔºâ
     * @return
     */
    private List<BtPositionRecordDO> todayClearPositionRecordList(Long taskId,
                                                                  LocalDate endTradeDate,
                                                                  Map<String, BtTradeRecordDO> todayClearMap) {


        List<BtPositionRecordDO> clearPositionRecordDOList = Lists.newArrayList();


        todayClearMap.forEach((stockCode, tr) -> {


            // ÂΩìÊó•Êî∂Áõò‰ª∑
            double closePrice = getClosePrice(stockCode, endTradeDate);


            // ---------------------------------------------------------------------------------------------------------
            //                                              ËÆ°ÁÆóÂΩìÊó•ÊµÆÂä®Áõà‰∫è
            // ---------------------------------------------------------------------------------------------------------


            double todayPnl = 0;
            double todayPnlPct = 0;


            double closeTodayReturnPct = 0;

            double priceTotalReturnPct = 0;
            double priceMaxReturnPct = 0;
            double priceMaxDrawdownPct = 0;


            // Êò®Êó•ÊåÅ‰ªì Êï∞Èáè„ÄÅÊàêÊú¨
            BtPositionRecordDO prevPos = x.get().prev__stockCode_positionDO_Map.get(stockCode);
            if (prevPos == null) {
                return;
            }


            // È¶ñÊ¨°‰π∞ÂÖ•‰ª∑Ê†º
            double initBuyPrice = prevPos.getInitBuyPrice().doubleValue();


            double prevAvgCostPrice = prevPos.getAvgCostPrice().doubleValue();
            double prevClosePrice = prevPos.getClosePrice().doubleValue();
            double prevQty = prevPos.getQuantity();
            double prevTotalCost = prevAvgCostPrice * prevQty;


            // ---------------------------------------------------------------------------------------------------------


            // ÊÄªÊàêÊú¨
            double totalCost = prevTotalCost;
            // Âπ≥ÂùáÊàêÊú¨ = ÊÄªÊàêÊú¨ / ÊåÅ‰ªìÊï∞Èáè
            double avgCost = prevAvgCostPrice;


            // ---------------------------------------------------------------------------------------------------------


            // ‰ªäÊó•ÂçñÂá∫ -> ‰∏çÁî®ÁâπÊÆäÂ§ÑÁêÜÔºåÂõ†‰∏∫Á≥ªÁªüÁ∫¶ÂÆö‚ÄúÂçñÂá∫ = ÂÖ®ÈÉ®Ê∏Ö‰ªì‚ÄùÔºåÂõ†Ê≠§ qty Â∑≤Áªè‰ª£Ë°®ÂΩìÊó•ÊúÄÁªàÊåÅ‰ªì


            // Êò®Êó•ÊåÅ‰ªìÈÉ®ÂàÜÁöÑ ÂΩìÊó•ÊµÆÂä®Áõà‰∫è = (‰ªäÊó•Êî∂Áõò‰ª∑ - Êò®Êó•Êî∂Áõò‰ª∑) * Êò®Êó•ÊåÅ‰ªìÊï∞Èáè
            double pnlFromYesterday = (closePrice - prevClosePrice) * prevQty;


            // ‰ªäÊó•Êñ∞Â¢û‰π∞ÂÖ•ÈÉ®ÂàÜÁöÑÂΩìÊó•ÊµÆÂä®Áõà‰∫è = (‰ªäÊó•Êî∂Áõò‰ª∑ - ‰ªäÊó•‰π∞ÂÖ•‰ª∑) * ‰ªäÊó•‰π∞ÂÖ•Êï∞Èáè
            // Áî±‰∫éÊâÄÊúâ‰∫§ÊòìÈÉΩÂèëÁîüÂú®Êî∂Áõò‰ª∑ÔºåÂõ†Ê≠§‰ªäÊó•‰π∞ÂÖ•‰ª∑ = ‰ªäÊó•Êî∂Áõò‰ª∑ÔºåÂΩìÊó•ÊµÆÁõà=0
            double pnlFromTodayBuy = 0;


            // ÂΩìÊó•ÊµÆÂä®Áõà‰∫èÊÄªÈ¢ù
            todayPnl = pnlFromYesterday + pnlFromTodayBuy;


            // ÂΩìÊó•ÊµÆÂä®Áõà‰∫èÁéá = ÂΩìÊó•Áõà‰∫èÈ¢ù / Êò®Êó•ÊåÅ‰ªìÊàêÊú¨
            // ‚ö†Ô∏è Ê≥®ÊÑèÔºöÂàÜÊØçÂøÖÈ°ªÊòØÊò®Êó•ÁöÑÊàêÊú¨ÔºåËÄå‰∏çÊòØ‰ªäÊó•ÊÄªÊàêÊú¨ÔºåÂê¶Âàô‰ºöÁ®ÄÈáäÊéâÂΩìÊó•Áõà‰∫è
            // todayPnlPct = (prevTotalCost > 0) ? (todayPnl * 100 / prevTotalCost) : 0;


            // ÂΩìÊó•ÊµÆÂä®Áõà‰∫èÁéá = ÂΩìÊó•Áõà‰∫èÈ¢ù / ÊÄªÊàêÊú¨
            // ‚ö†Ô∏è Ê≥®ÊÑèÔºöÂàÜÊØçÂøÖÈ°ªÊòØ‰ªäÊó•ÁöÑÊÄªÊàêÊú¨Ôºå‰ªäÊó•Êñ∞‰π∞ÂÖ•  ->  ‰ºöÁ≠âÊØî‰æã Á®ÄÈáäÊéâÂΩìÊó•Áõà‰∫è
            todayPnlPct = (totalCost > 0) ? (todayPnl * 100 / totalCost) : 0;


            if (todayPnlPct > 30 || todayPnlPct < -30) {
                log.error("todayClearPositionRecordList - err     >>>     taskId : {} , tradeDate : {} , stockCode : {}   ,   todayPnlPct : {} , todayPnl : {} ,totalCost : {} , prevPos : {} , todayTr : {}", taskId, endTradeDate, stockCode, todayPnlPct, todayPnl, totalCost, JSON.toJSONString(prevPos), JSON.toJSONString(prevPos));

                // TODO   ÂèëÁé∞Êúâ SÂêé Ââ©‰Ωô1ËÇ° bug
                todayPnlPct = Math.min(todayPnlPct, 9999.99);
                todayPnlPct = Math.max(todayPnlPct, -9999.99);
            }


            // ---------------------------------------------------------------------------------------------------------


            // ÂΩìÊó•Ê∂®Ë∑åÂπÖÔºà%Ôºâ
            closeTodayReturnPct = (closePrice / prevClosePrice - 1) * 100;


            // È¶ñÊ¨°‰π∞ÂÖ•‰ª∑Ê†º-Á¥ØËÆ°Ê∂®ÂπÖÔºà%Ôºâ =  ÂΩìÊó•Êî∂Áõò‰ª∑ / initBuyPrice  - 1
            priceTotalReturnPct = (closePrice / initBuyPrice - 1) * 100;


            // Êò®Êó•-ÊúÄÂ§ßÊ∂®ÂπÖ
            priceMaxReturnPct = prevPos.getPriceMaxReturnPct().doubleValue();
            // Êò®Êó•-ÊúÄÂ§ßÂõûÊí§
            priceMaxDrawdownPct = prevPos.getPriceMaxDrawdownPct().doubleValue();


            // È¶ñÊ¨°‰π∞ÂÖ•‰ª∑Ê†º-ÊúÄÂ§ßÊ∂®ÂπÖÔºà%Ôºâ
            if (priceMaxReturnPct < priceTotalReturnPct) {
                priceMaxReturnPct = priceTotalReturnPct;
                // maxDate = tradeDate;
            }


            // ÂΩìÊó•ÂõûÊí§ÔºàË¥üÊï∞Ôºâ  =  ÔºàÂΩìÊó•ÔºâÁ¥ØËÆ°ÂáÄÂÄº / ÊúÄÂ§ßÂáÄÂÄº
            double drawdownPct = ((1 + priceTotalReturnPct * 0.01) / (1 + priceMaxReturnPct * 0.01) - 1) * 100;


            // È¶ñÊ¨°‰π∞ÂÖ•‰ª∑Ê†º-ÊúÄÂ§ßÂõûÊí§Ôºà%Ôºâ
            if (priceMaxDrawdownPct > drawdownPct) {
                priceMaxDrawdownPct = drawdownPct;
                // minDate = tradeDate;
                // minNav = nav;
            }


            // ---------------------------------------------------------------------------------------------------------


            // Á¥ØËÆ°ÊµÆÂä®Áõà‰∫è = ÔºàÂΩìÊó•Êî∂Áõò‰ª∑ - Âπ≥ÂùáÊàêÊú¨Ôºâx ÊåÅ‰ªìÊï∞Èáè
            double totalPnl = (closePrice - avgCost) * prevQty;

            // Á¥ØËÆ°ÊµÆÂä®Áõà‰∫èÁéáÔºà%Ôºâ
            double pnlPct = totalPnl / totalCost * 100;


            // ---------------------------------------------------------------------------------------------------------


            BtPositionRecordDO positionRecordDO = new BtPositionRecordDO();

            positionRecordDO.setTaskId(taskId);
            positionRecordDO.setTradeDate(endTradeDate);
            positionRecordDO.setStockId(prevPos.getStockId());
            positionRecordDO.setStockCode(stockCode);
            positionRecordDO.setStockName(prevPos.getStockName());

            positionRecordDO.setAvgCostPrice(of(avgCost));
            positionRecordDO.setClosePrice(of(closePrice));
            // Ê∏Ö‰ªìÊï∞Èáè
            positionRecordDO.setQuantity(tr.getQuantity());
            positionRecordDO.setAvlQuantity(0);


            // ÂΩìÂâçÂ∏ÇÂÄº = Ê∏Ö‰ªìÊï∞Èáè x ÂΩìÂâçÊî∂Áõò‰ª∑
            positionRecordDO.setMarketValue(of(tr.getQuantity() * closePrice));

            // ‰ªì‰ΩçÂç†ÊØî = Ê∏Ö‰ªìÂ∏ÇÂÄº / ÊÄªËµÑÈáë
            BigDecimal positionPct = positionRecordDO.getMarketValue().divide(of(x.get().capital), 8, RoundingMode.HALF_UP).multiply(BigDecimal.valueOf(100));
            positionRecordDO.setPositionPct(positionPct);


            // ÂΩìÊó•Áõà‰∫èÈ¢ù
            positionRecordDO.setCapTodayPnl(of(todayPnl));
            // ÂΩìÊó•Áõà‰∫èÁéáÔºà%Ôºâ
            positionRecordDO.setCapTodayPnlPct(of(todayPnlPct));

            // Á¥ØËÆ°Áõà‰∫èÈ¢ù
            positionRecordDO.setCapTotalPnl(of(totalPnl));
            // Á¥ØËÆ°Áõà‰∫èÁéáÔºà%Ôºâ = Áõà‰∫èÈ¢ù / ÊÄªÊàêÊú¨  x 100%
            positionRecordDO.setCapTotalPnlPct(of(pnlPct));


            // ÂΩìÊó•Ê∂®Ë∑åÂπÖÔºà%Ôºâ
            positionRecordDO.setChangePct(of(closeTodayReturnPct));

            // È¶ñÊ¨°‰π∞ÂÖ•‰ª∑Ê†º-Á¥ØËÆ°Ê∂®ÂπÖÔºà%Ôºâ
            positionRecordDO.setPriceTotalReturnPct(of(priceTotalReturnPct));
            // È¶ñÊ¨°‰π∞ÂÖ•‰ª∑Ê†º-ÊúÄÂ§ßÊ∂®ÂπÖÔºà%Ôºâ
            positionRecordDO.setPriceMaxReturnPct(of(priceMaxReturnPct));
            // È¶ñÊ¨°‰π∞ÂÖ•‰ª∑Ê†º-ÊúÄÂ§ßÂõûÊí§Ôºà%Ôºâ
            positionRecordDO.setPriceMaxDrawdownPct(of(priceMaxDrawdownPct));


            positionRecordDO.setBuyDate(prevPos.getBuyDate());
            positionRecordDO.setHoldingDays(prevPos.getHoldingDays() + 1);


            // ---------------------------------------------------------------------------------------------------------


            if (null == positionRecordDO.getPriceMaxDrawdownPct()) {
                log.error("todayClearPositionRecordList - getPriceMaxDrawdownPct err     >>>     taskId : {} , tradeDate : {} , stockCode : {} , positionRecordDO : {}",
                          taskId, endTradeDate, stockCode, JSON.toJSONString(positionRecordDO));
            }


            // ÊåÅ‰ªìÁä∂ÊÄÅÔºö1-ÊåÅ‰ªì‰∏≠Ôºõ2-Â∑≤Ê∏Ö‰ªìÔºõ
            positionRecordDO.setPositionType(2);
            clearPositionRecordDOList.add(positionRecordDO);
        });


        // -------------------------------------------------------------------------------------------------------------


        // ÂΩìÊó•Ê∏Ö‰ªì ÂàóË°®
        // x.get().clearPositionRecordDOList = clearPositionRecordDOList;


        // -------------------------------------------------------------------------------------------------------------


        return clearPositionRecordDOList;
    }


    /**
     * ‰∏™ËÇ°   ÊåáÂÆöÊó•Êúü -> Êî∂Áõò‰ª∑
     *
     * @param stockCode
     * @param tradeDate
     * @return
     */
    private double getClosePrice(String stockCode, LocalDate tradeDate) {
        Double closePrice = data.stock__dateCloseMap.get(stockCode).get(tradeDate);


        // ÂÅúÁâåÔºà603039 -> 2023-04-03Ôºâ
        int count = 0;
        while (closePrice == null && count++ < 500) {
            // ‰∫§ÊòìÊó• ÂæÄÂâç‰∏Ä‰Ωç
            tradeDate = tradeDateDecr(tradeDate);
            closePrice = data.stock__dateCloseMap.get(stockCode).get(tradeDate);
        }


        return closePrice == null ? 0.0 : closePrice;
    }


    @Synchronized
    private void initData(LocalDate startDate, LocalDate endDate) {
        log.info("--------------------------- " + Thread.currentThread().getName() + "Á∫øÁ®ã Á´û‰∫âÂà∞‰∫Üüîê     >>>     üßë‚Äçüíªüèá");


        // ÈáçÊñ∞ÂàùÂßãÂåñ   ÁªüËÆ°Êï∞ÊçÆ
        // x = new Stat();
        x.set(new Stat());


        tradeRecord___idSet__cache.set(Sets.newHashSet());
        tradeRecordList__cache.set(Lists.newArrayList());


        log.info("--------------------------- data.stockDOList - before     >>>     size : {} , Á∫øÁ®ã : {}",
                 ListUtil.size(data.stockDOList), Thread.currentThread().getName());


        // ÂÖ®ÈáèË°åÊÉÖ
        data = initDataService.initData(startDate, endDate, false);
        // initDataService.initData(startDate, endDate, false);   // Á≠â‰ª∑ data = ÂÖ®Â±ÄCache;       data -Êú¨Ë∫´Â∞±Â∑≤ÂÖ®Â±ÄÊåáÂêë-> ÂÖ®Â±ÄCache


        log.info("--------------------------- data.stockDOList - after      >>>     size : {} , Á∫øÁ®ã : {}",
                 ListUtil.size(data.stockDOList), Thread.currentThread().getName());
    }


    // -----------------------------------------------------------------------------------------------------------------


    @Data
    public static class Backup {
        Stat x = new Stat();
        Set<Long> tradeRecord___idSet__cache;
        List<BtTradeRecordDO> tradeRecordList__cache;
    }


    /**
     * Â§á‰ªΩ
     */
    private Backup backupThreadLocal() {
        Backup backup = new Backup();

        // Ê∑±Êã∑Ë¥ù
        backup.x = DeepCopyUtil.deepCopy(x.get());
        backup.tradeRecord___idSet__cache = Sets.newHashSet(tradeRecord___idSet__cache.get());
        backup.tradeRecordList__cache = Lists.newArrayList(tradeRecordList__cache.get());

        return backup;
    }

    /**
     * ÊÅ¢Â§ç
     */
    private void restoreThreadLocal(Backup backup) {
        x.set(backup.x);
        tradeRecord___idSet__cache.set(backup.tradeRecord___idSet__cache);
        tradeRecordList__cache.set(backup.tradeRecordList__cache);
    }


    /**
     * Ê∏ÖÁêÜ
     */
    private void clearThreadLocal() {
        x.remove();
        tradeRecord___idSet__cache.remove();
        tradeRecordList__cache.remove();
    }


    // -----------------------------------------------------------------------------------------------------------------


    @Data
    @AllArgsConstructor
    public static class CalcStat {


        // ----------------------------------------- ‰∏çÂèò


        // ÂΩìÂâç ‰ªì‰ΩçÈôêÂà∂Ôºà‰∏çÂèòÔºâ
        double positionLimitRate;       // ‰ªì‰ΩçÁôæÂàÜÊØî ‰∏äÈôê     =>     Â§ßÁõòÈáèÂåñ -> ËÆ°ÁÆó
        double positionLimitAmount;     // ‰ªì‰ΩçÊÄªÈáëÈ¢ù ‰∏äÈôê     =      ÊÄªËµÑÈáë  x  ‰ªì‰ΩçÁôæÂàÜÊØî ‰∏äÈôê


        // ÂΩìÂâç ÊÄªËµÑÈáëÔºàB/S ‰ªªÊÑèÂèòÊç¢   ->   capital ‰∏çÂèòÔºâ   =   ÊåÅ‰ªìÊÄªÂ∏ÇÂÄºÔºàË∑üÈöèBS ÂèòÂä®Ôºâ +  ÂèØÁî®ËµÑÈáëÔºàË∑üÈöèBS ÂèòÂä®Ôºâ
        double capital;


        // ------------------------------------------------------------


        // ----------------------------------------- ÂèØÂèò


        // ÂΩìÂâç ÊåÅ‰ªìÂàóË°®
        List<BtPositionRecordDO> positionRecordDOList;
        List<String> positionStockCodeList;
        Map<String, BtPositionRecordDO> stockCode_positionDO_Map = Maps.newHashMap();


        // ÂΩìÂâç ÊåÅ‰ªìÊÄªÂ∏ÇÂÄº   <=   ‰ªì‰ΩçÈôêÂà∂
        double marketValue;


        // ÂΩìÂâç ÂèØÁî®ËµÑÈáë   =   ÊÄªËµÑÈáë - ÊåÅ‰ªìÊÄªÂ∏ÇÂÄº
        double avlCapital;

        // ÂΩìÂâç ÂÆûÈôÖÂèØÁî®ËµÑÈáëÔºàÂ§ßÁõò -> ‰ªì‰ΩçÈôêÂà∂Ôºâ  =   ‰ªì‰ΩçÊÄªÈáëÈ¢ù ‰∏äÈôê   -   ÊåÅ‰ªìÊÄªÂ∏ÇÂÄº
        double actAvlCapital;


        // ----------------------------------------- ÂèØÂèò


        // ‰ªäÊó• B/SËÆ∞ÂΩï
        List<BtTradeRecordDO> tradeRecordDOList;

        // ÂçñÂá∫ÊÄªÈáëÈ¢ù
        double sellCapital;
        // ‰π∞ÂÖ•ÊÄªÈáëÈ¢ù
        double buyCapital;


        // ------------------------------------------------------------


        public CalcStat(List<BtPositionRecordDO> positionRecordDOList, List<BtTradeRecordDO> tradeRecordDOList) {


            // ------------------------------------------ ‰∏çÂèòÔºàÂ∑≤ËÆ°ÁÆóÔºâ


            this.positionLimitRate = x.get().positionLimitRate;
            this.positionLimitAmount = x.get().positionLimitAmount;
            this.capital = x.get().capital;


            // ------------------------------------------ ÂèØÂèòÔºàB/SËÆ∞ÂΩï -> ÂÆûÊó∂ËÆ°ÁÆóÔºâ


            // ‰ªäÊó• B/SËÆ∞ÂΩï
            this.tradeRecordDOList = tradeRecordDOList;

            this.sellCapital = getSellCapital();
            this.buyCapital = getBuyCapital();


            // ------------------------------------------ ÂèØÂèòÔºàÊåÅ‰ªìÂàóË°® -> ÂÆûÊó∂ËÆ°ÁÆóÔºâ


            // ÂΩìÂâç ÊåÅ‰ªìÂàóË°®
            this.positionRecordDOList = positionRecordDOList;
            this.positionStockCodeList = getPositionStockCodeList();
            this.stockCode_positionDO_Map = getStockCode_positionDO_Map();


            this.marketValue = getMarketValue();
            this.avlCapital = getAvlCapital();
            this.actAvlCapital = getActAvlCapital();


            // ------------------------------------------


            // check
            checkStatData();
        }


        private void checkStatData() {

            // ÊÄªËµÑÈáë  =  ÊÄªÂ∏ÇÂÄº + ÂèØÁî®ËµÑÈáë
            double capital_2 = marketValue + avlCapital;
            if (!TdxFunCheck.equals(capital, capital_2)) {
                log.warn("check err     >>>     [{}] [{}] , capital : {} , capital_2 : {}",
                         x.get().taskId, x.get().tradeDate, capital, capital_2);
            }

            // ÂèØÁî®ËµÑÈáë  =  prev_ÂèØÁî®ËµÑÈáë + ÂçñÂá∫ - ‰π∞ÂÖ•
            double avlCapital_2 = x.get().prevAvlCapital + sellCapital - buyCapital;
            if (tradeRecordDOList != null && !TdxFunCheck.equals(avlCapital, avlCapital_2, x.get().capital * 0.001 /*1000*/, 0.01)) {
                log.warn("check err     >>>     [{}] [{}] , avlCapital : {} , avlCapital_2 : {}",
                         x.get().taskId, x.get().tradeDate, avlCapital, avlCapital_2);
            }
        }


        // ------------------------------------------------------------


        // -------------------------- ÊåÅ‰ªì


        public List<String> getPositionStockCodeList() {
            // ÊåÅ‰ªì codeÂàóË°®
            this.positionStockCodeList = positionRecordDOList.stream().map(BtPositionRecordDO::getStockCode).collect(Collectors.toList());
            return this.positionStockCodeList;
        }


        public Map<String, BtPositionRecordDO> getStockCode_positionDO_Map() {
            positionRecordDOList.forEach(e -> stockCode_positionDO_Map.put(e.getStockCode(), e));
            return stockCode_positionDO_Map;
        }

        public double getMarketValue() {
            if (CollectionUtils.isEmpty(positionRecordDOList)) {
                return 0;
            }

            return positionRecordDOList.stream()
                                       .map(BtPositionRecordDO::getMarketValue)
                                       .reduce(BigDecimal.ZERO, BigDecimal::add)
                                       .doubleValue();
        }

        public double getAvlCapital() {
            double avlCapital_1 = capital - marketValue;
            double avlCapital_2 = x.get().prevAvlCapital + sellCapital - buyCapital;

            // ÂâçÁΩÆinitÈò∂ÊÆµ -> ‰∏çÊ†°È™å Ôºàcapital -> ËøòÊú™ËÆ°ÁÆóÔºâ
            if (tradeRecordDOList != null && !TdxFunCheck.equals(avlCapital_1, avlCapital_2, 1000, 0.01)) {
                log.warn("getAvlCapital err     >>>     [{}] [{}] , {} , {}", x.get().taskId, x.get().tradeDate, avlCapital_1, avlCapital_2);
            }

            return avlCapital_1;
        }

        public double getActAvlCapital() {
            return actAvlCapital = positionLimitAmount - marketValue;
        }


        // -------------------------- B/S


        public double getSellCapital() {
            if (CollectionUtils.isEmpty(tradeRecordDOList)) {
                return 0;
            }

            return tradeRecordDOList.stream()
                                    .filter(e -> e.getTradeType().equals(BtTradeTypeEnum.SELL.getTradeType()))
                                    .map(BtTradeRecordDO::getAmount)
                                    .reduce(BigDecimal.ZERO, BigDecimal::add)
                                    .doubleValue();
        }

        public double getBuyCapital() {
            if (CollectionUtils.isEmpty(tradeRecordDOList)) {
                return 0;
            }

            return tradeRecordDOList.stream()
                                    .filter(e -> e.getTradeType().equals(BtTradeTypeEnum.BUY.getTradeType()))
                                    .map(BtTradeRecordDO::getAmount)
                                    .reduce(BigDecimal.ZERO, BigDecimal::add)
                                    .doubleValue();
        }
    }


    /**
     * ÁªüËÆ°Êï∞ÊçÆ
     */
    @Data
    public static class Stat implements Serializable {


        // -------------------- ÊØèÊó•


        // ÊÄªËµÑÈáë
        double prevCapital;
        // ÂèØÁî®ËµÑÈáë
        double prevAvlCapital;

        // ÊåÅ‰ªìÂàóË°®
        // List<BtPositionRecordDO> prevPositionRecordDOList;
        Map<String, BtPositionRecordDO> prev__stockCode_positionDO_Map = Maps.newHashMap();


        // ----------------------------------------------------------------------------------


        // taskId
        Long taskId;

        // ÂΩìÂâç ‰∫§ÊòìÊó•
        LocalDate tradeDate;


        // ----------------------------------------------------------------------------------


        // SÂâçÔºàÊò®Êó•ÊåÅ‰ªìÔºâ -> S -> SÂêéÔºàÂáè‰ªìÂâçÔºâ -> Âáè‰ªì -> Âáè‰ªìÂêéÔºàBÂâçÔºâ -> B -> BÂêé


        // ----------------------------------------- ‰∏çÂèò


        // ÂΩìÂâç ‰ªì‰ΩçÈôêÂà∂Ôºà‰∏çÂèòÔºâ
        double positionLimitRate;       // ‰ªì‰ΩçÁôæÂàÜÊØî ‰∏äÈôê     =>     Â§ßÁõòÈáèÂåñ -> ËÆ°ÁÆó
        double positionLimitAmount;     // ‰ªì‰ΩçÊÄªÈáëÈ¢ù ‰∏äÈôê     =      ÊÄªËµÑÈáë  x  ‰ªì‰ΩçÁôæÂàÜÊØî ‰∏äÈôê


        // ÂΩìÂâç ÊÄªËµÑÈáëÔºàB/S ‰ªªÊÑèÂèòÊç¢   ->   capital ‰∏çÂèòÔºâ   =   ÊåÅ‰ªìÊÄªÂ∏ÇÂÄºÔºàË∑üÈöèBS ÂèòÂä®Ôºâ +  ÂèØÁî®ËµÑÈáëÔºàË∑üÈöèBS ÂèòÂä®Ôºâ
        double capital;


        // ----------------------------------------- ÂèØÂèò


        // ÊåÅ‰ªìÂàóË°®
        List<BtPositionRecordDO> positionRecordDOList;
        List<String> positionStockCodeList;
        Map<String, BtPositionRecordDO> stockCode_positionDO_Map = Maps.newHashMap();


        // Ê∏Ö‰ªìÂàóË°®
        List<BtPositionRecordDO> clearPositionRecordDOList;


        // --------------------


        // ÂΩìÂâç ÊåÅ‰ªìÊÄªÂ∏ÇÂÄº   <=   ‰ªì‰ΩçÈôêÂà∂
        double marketValue;


        // ÂΩìÂâç ÂèØÁî®ËµÑÈáë   =   ÊÄªËµÑÈáë - ÊåÅ‰ªìÊÄªÂ∏ÇÂÄº
        double avlCapital;

        // ÂΩìÂâç ÂÆûÈôÖÂèØÁî®ËµÑÈáëÔºàÂ§ßÁõò -> ‰ªì‰ΩçÈôêÂà∂Ôºâ  =   ‰ªì‰ΩçÊÄªÈáëÈ¢ù ‰∏äÈôê   -   ÊåÅ‰ªìÊÄªÂ∏ÇÂÄº
        double actAvlCapital;


        // ----------------------------------------- ÂèØÂèò


        // -------------------- B/SÁ≠ñÁï•

        double sellCapital;
        double buyCapital;
    }


    @Data
    @AllArgsConstructor
    public static class PositionInfo {
        private Long stockId;
        private String stockCode;
        private String stockName;
        private LocalDate buyDate;
        private BigDecimal initBuyPrice;
        // private Integer holdingDays;

        public Integer getHoldingDays(LocalDate endTradeDate, Map<LocalDate, Integer> dateIndexMap) {
            // ÊåÅ‰ªìÂ§©Êï∞   ->   Èó¥Èöî  N‰∏™‰∫§ÊòìÊó•
            return between(buyDate, endTradeDate, dateIndexMap);
        }
    }


    /**
     * ‰∏§‰∏™‰∫§ÊòìÊó•   Èó¥ÈöîÂ§©Êï∞(‰∫§ÊòìÊó•)
     *
     * @param start
     * @param end
     * @param dateIndexMap ‰∫§ÊòìÊó•-idx
     * @return
     */
    public static int between(LocalDate start, LocalDate end, Map<LocalDate, Integer> dateIndexMap) {
        Assert.isTrue(!start.isAfter(end), String.format("start[%s]‰∏çËÉΩÂ§ß‰∫éend[%s]", start, end));


        Integer idx1 = dateIndexMap.get(start);
        Integer idx2 = dateIndexMap.get(end);

        Assert.notNull(idx1, String.format("start[%s]Èùû‰∫§ÊòìÊó•", start));
        Assert.notNull(idx2, String.format("end[%s]Èùû‰∫§ÊòìÊó•", end));

        return idx2 - idx1;
    }


    private static BigDecimal of(Number val) {
        return NumUtil.num2Decimal(val, 4);
    }


    /**
     * ËæÖÂä©Á±ªÔºöÂåÖË£Ö‰∏ÄÊù°‰π∞ÂÖ•ËÆ∞ÂΩïÂèäÂÖ∂Ââ©‰ΩôÂèØÊäµÈîÄÊï∞Èáè
     **/
    @Data
    @AllArgsConstructor
    private static class MutableTrade {
        // ‰π∞ÂÖ•ËÆ∞ÂΩï
        final BtTradeRecordDO original;
        // Ââ©‰ΩôÂèØÊäµÈîÄÊï∞Èáè
        int remainingQty;
    }


    public static class DrawdownResult {

        // Ê≥¢Â≥∞
        public LocalDate peakDate;
        public BigDecimal peakNav;

        // Ê≥¢Ë∞∑
        public LocalDate troughDate;
        public BigDecimal troughNav;

        // ÊúÄÂ§ßË∑åÂπÖÔºàË¥üÊï∞Ôºâ
        public BigDecimal drawdownPct;


        // -------------------------

        // ÁõàÂà©Â§©Êï∞
        public int profitDayCount;


        // -------------------------


        // ÊØèÊó•Êî∂ÁõäÁéá ÂàóË°®
        List<BigDecimal> dailyReturnList = Lists.newArrayList();
    }


}